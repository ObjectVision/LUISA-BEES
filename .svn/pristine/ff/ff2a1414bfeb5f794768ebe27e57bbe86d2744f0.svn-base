container RunRegions: Using = "Geography/AdministrativeBoundaries;"
{
	
	attribute<UnitSets/base_zones> base_raster (domain_grid): expr = "poly2grid(UnitSets/base_zones/Geometry, domain_grid, 1)";
	
	container RasterSets: expr = "for_each_nedvn(BoundarySets/uniName, 'base_rels/'+ BoundarySets/uniName +'[base_raster]', domain_grid, UnitSets, BoundarySets/uniName)", FreeData = "False"
	{
		attribute<UnitSets/RunAreas> 			RunAreas 			(domain_grid): 	expr = "base_rels/RunAreas[base_raster]";
		attribute<UnitSets/ForestDemandRegions> ForestDemandRegions (domain_grid): 	expr = "base_rels/ForestDemandRegions[base_raster]";
		attribute<UnitSets/Capri> 				Capri 				(domain_grid): 	expr = "base_rels/Capri[base_raster]";
	}
	
	container UnitSets: expr = "for_each_ind('nex', BoundarySets/uniName, 'RegionalSets/'+ BoundarySets/uniName +'/Set16',uint16)", FreeData = "False"
	{
		unit<uint16> base_zones: 			expr = "RegionalSets/base_zones/Set16" 
		{
			attribute<LambertEA> centroid: expr = "centroid_or_mid(Geometry)"; 
			attribute<float32> area: expr = "float32(area(base_zones/Geometry, float64)) / float32(1000 * 1000)";
			
			attribute<LambertEA> lu_weighted_centroid (.): expr = "sum(relevant_pixel, base_raster) / sum(point(float64(!IsNull(CaseData/PrepareVariables/LandUseGrid)), float64(!IsNull(CaseData/PrepareVariables/LandUseGrid)), LambertEA), base_raster)", KeepData = "True";
			attribute<LambertEA> relevant_pixel (domain_grid): expr = "!IsNull(CaseData/PrepareVariables/LandUseGrid) ? id(domain_grid)[LambertEA] : point(float64(0),float64(0),LambertEA)";
		}
		unit<uint16> RunAreas:		 		expr = "RegionalSets/RunAreas/Set16";
		unit<uint16> ForestDemandRegions:	expr = "RegionalSets/ForestDemandRegions/Set16";
		unit<uint16> Capri:					expr = "RegionalSets/Capri/Set16";
		
	}
	container UnitSets32: expr = "for_each_ind('nex', BoundarySets/uniName, 'RegionalSets/'+ BoundarySets/uniName +'/Set',uint32)", FreeData = "False"
	{
		unit<uint32> base_zones: 			expr = "RegionalSets/base_zones/Set" {attribute<LambertEA> centroid: expr = "centroid_or_mid(Geometry)"; attribute<float32> area: expr = "float32(area(base_zones/Geometry, float64)) / float32(1000 * 1000)";}
		unit<uint32> RunAreas:		 		expr = "RegionalSets/RunAreas/Set";
	}
	
	container base_rels: expr = "for_each_nedvn(BoundarySets/uniName, "
	 "'MakeDefined(point_in_polygon(UnitSets/base_zones/centroid, UnitSets/'+ BoundarySets/uniName +'/Geometry), '+"
		"'point_in_polygon(UnitSets/base_zones/lu_weighted_centroid, UnitSets/'+ BoundarySets/uniName +'/Geometry))',"
		"UnitSets/base_zones, UnitSets, BoundarySets/uniName)"
	{
		attribute<UnitSets/RunAreas> 			RunAreas 			(UnitSets/base_zones): expr = "MakeDefined(point_in_polygon(UnitSets/base_zones/centroid, UnitSets/RunAreas/Geometry), point_in_polygon(UnitSets/base_zones/lu_weighted_centroid, UnitSets/RunAreas/Geometry))";
		attribute<UnitSets/ForestDemandRegions> ForestDemandRegions (UnitSets/base_zones): expr = "MakeDefined(point_in_polygon(UnitSets/base_zones/centroid, UnitSets/ForestDemandRegions/Geometry), point_in_polygon(UnitSets/base_zones/lu_weighted_centroid, UnitSets/ForestDemandRegions/Geometry))";
		attribute<UnitSets/Capri> 				Capri 				(UnitSets/base_zones): expr = "MakeDefined(point_in_polygon(UnitSets/base_zones/centroid, UnitSets/Capri/Geometry), point_in_polygon(UnitSets/base_zones/lu_weighted_centroid, UnitSets/Capri/Geometry))";
	}
	
	container base_rels32: expr = "for_each_nedvn(BoundarySets/uniName, "
	 "'point_in_polygon(UnitSets32/base_zones/centroid, UnitSets32/'+ BoundarySets/uniName +'/Geometry)', UnitSets32/base_zones, UnitSets32, BoundarySets/uniName)"
	{
		//attribute<UnitSets32/RunAreas> 			  RunAreas 				(UnitSets32/base_zones): expr = "point_in_polygon(UnitSets32/base_zones/centroid, UnitSets32/RunAreas/Geometry)";
		//attribute<UnitSets32/ForestDemandRegions> ForestDemandRegions 	(UnitSets32/base_zones): expr = "point_in_polygon(UnitSets32/base_zones/centroid, UnitSets32/ForestDemandRegions/Geometry)";
		//attribute<UnitSets32/Capri> 			  Capri 				(UnitSets32/base_zones): expr = "point_in_polygon(UnitSets32/base_zones/centroid, UnitSets32/Capri/Geometry)";
	}

	
	container RegionalSets: expr = "for_each_ne(BoundarySets/uniName, 'getRegionSet('+string(JrcRegionId)+'[Geography/Regions/Runs], '+ quote(BoundarySets/uniName) +')')"
	{
		container base_zones: 			expr = "getRegionSet(JrcRegionId, 'base_zones')";
		container RunAreas:		  		expr = "getRegionSet(JrcRegionId, 'RunAreas')";
		container Capri:				expr = "getRegionSet(JrcRegionId, 'Capri')";
		container ForestDemandRegions: 	expr = "getRegionSet(JrcRegionId, 'ForestDemandRegions')";
	}
	container region_overlays: expr = "for_each_ind('nex', BoundarySets/uniName, 'overlay_polygon(value(RegionalSets/'+ BoundarySets/uniName +'/set/Buffered, ipoint), value(RegionalSets/'+ BoundarySets/uniName +'/set/Buffered, ipoint))', uint32)"
	{
		unit<uint32> Capri: 	expr = "overlay_polygon(value(RegionalSets/Capri/set/Buffered, ipoint), 	value(RegionalSets/Capri/set/Buffered, ipoint))";
	}
	
	container contiguity_matrices: expr = "for_each_ne(BoundarySets/uniName, 'getContiguityMatrices(UnitSets/'+ BoundarySets/uniName +', region_overlays/'+ BoundarySets/uniName +')')", FreeData = "False"
	{
		container Capri: 		expr = "getContiguityMatrices(UnitSets/Capri, region_overlays/Capri)";
	}
	
	container getRegionSet: IsTemplate = "True"
	{
		parameter<Geography/Regions/Runs>				RunRegion;
		parameter<string> 								inZoneSetName;
		
		unit<uint32> OrgZones: expr = "= 'Geography/Regions/' + inZoneSetName";
		
		unit<uint32> Set: expr = "= 'subset(relational/'+ inZoneSetName +' = '+ string(RunRegion) +'[Geography/Regions/Runs])'",
			DialogData = "Geometry",
			DialogType = "map"
		{
			attribute<string> 		ZoneId: 				expr = "OrgZones/ZoneId[Nr_OrgEntity]";
			attribute<LambertEA> 	Geometry	(polygon): 	expr = "OrgZones/Geometry[Nr_OrgEntity]";
			attribute<string>		Label:					expr = "ZoneId";
			attribute<LambertEA>	Buffered	(polygon): 	expr = "polygon_inflated(value(Geometry, ipoint), float64(10))[LambertEA]";
		}
		unit<uint16> Set16: expr = "range(uint16, uint16(0), uint16(#Set))", DialogData = "Geometry", DialogType = "map"
		{
			attribute<OrgZones> 	Nr_OrgEntity: 		expr = "Set/Nr_OrgEntity[link32]";
			attribute<Set> 			link32:				expr = "id(.)[Set]";
			attribute<string> 		ZoneId:				expr = "Set/ZoneId[link32]";
			attribute<LambertEA> 	Geometry (polygon): expr = "Set/Geometry[link32]";
			attribute<string>		Label:				expr = "Set/Label[link32]";
			
		}
		
	}
	
	container getContiguityMatrices: IsTemplate = "True"
	{
		unit<uint32> zone_set;
		unit<uint32> overlay_set;
		
		unit<uint32> matrix: expr = "overlay_set"
		{
			attribute<zone_set> nr_1: expr = "first_rel";
			attribute<zone_set> nr_2: expr = "second_rel";
			attribute<float32>  proto_weight: 	expr = "nr_1 != nr_2 ? float32(1) : float32(0)";
			attribute<float32>  weight:			expr = "proto_weight / sum(proto_weight, nr_1)[nr_1]";
		}
		
	}
	
	
	

}