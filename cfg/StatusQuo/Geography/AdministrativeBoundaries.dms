container AdministrativeBoundaries
{
	
	parameter<uint32> NrBoundarySets := 7;
	parameter<uint32> NrAttributes   := 5;
	
	unit<uint32> BoundarySets := range(uint32, 0, NrBoundarySets)
	{
		unit<uint32> inElements := range(uint32, 0, NrBoundarySets * NrAttributes)
		{
			attribute<string> elements: [
				// name						//shape location	//shape name		//ZoneId field	//label field	
				
				'NUTS0_LUISA',				'NUTS/LUISA',		'n0_jul16',			'First_N2_3',	'First_N2_3', 	
				'NUTS1_LUISA',				'NUTS/LUISA',		'n1_jul16',			'NUTS_CODE',	'NUTS_LABEL',	
				'NUTS2_merged_LUISA',		'NUTS/LUISA',		'n2_merged_jul16',	'merge',		'merge',		
				'NUTS2_LUISA',				'NUTS/LUISA',		'n2_jul16',			'NUTS_CODE',	'NUTS_LABEL',	
				'NUTS3_LUISA',				'NUTS/LUISA',		'n3_mar17',			'NUTS_CODE',	'NUTS_LABEL',	
				'LAU2',						'LAU',				'LAU_2018_meters',	'GISCO_ID',	    'LAU_LABEL',
				'NUTS3_EuroStat',			'NUTS/EuroStat',	'Nuts3',			'NUTS_CODE',	'NUTS_LABEL'];
		}
		attribute<string> Name: 		expr = "inElements/elements[((id(.)*NrAttributes)+0)[inElements]]";
		attribute<string> Dir: 			expr = "inElements/elements[((id(.)*NrAttributes)+1)[inElements]]";
		attribute<string> File: 		expr = "inElements/elements[((id(.)*NrAttributes)+2)[inElements]]";
		attribute<string> IDfield: 		expr = "inElements/elements[((id(.)*NrAttributes)+3)[inElements]]";
		attribute<string> Labelfield: 	expr = "inElements/elements[((id(.)*NrAttributes)+4)[inElements]]";
		attribute<string> Path:			expr = "Dir + '/' + File";
		attribute<string> uniName:		expr = "Name";
		
	}
		
	container src := for_each_ne(BoundarySets/uniName, 'doLoadFiles('+ quote(BoundarySets/Path) +','+ quote(BoundarySets/IDfield) +','+ quote(BoundarySets/Labelfield) +')')
	{
		container LAU_spain_patch := doLoadFiles ('LAU/LAU_spain_patch','LAU_CODE','LAU_CODE');
	}
	
	container aggregations
	{
		container LAU2 := doAggregateSets(src/LAU2/inFile, src/LAU_spain_patch/inFile);
	}
	container BoundaryDomains
	{
		unit<uint32> RunAreas := LUISA_zones/RunAreas;
		unit<uint32> ForestDemandRegions := LUISA_zones/ForestDemandRegions;
		
		unit<uint32> NUTS0_LUISA        := src/NUTS0_LUISA/inFile
		{
			attribute<string> RunAreaId := ZoneID;
		}
		unit<uint32> NUTS1_LUISA        := src/NUTS1_LUISA/inFile
		{
			attribute<string> RunAreaId := left(ZoneID, 2);
		}
		unit<uint32> NUTS2_merged_LUISA := src/NUTS2_merged_LUISA/inFile;
		unit<uint32> NUTS2_LUISA        := src/NUTS2_LUISA/inFile;
		unit<uint32> NUTS3_LUISA        := src/NUTS3_LUISA/inFile;
		unit<uint32> LAU2               := aggregations/LAU2/UniqueZones
		{
			attribute<string> ZoneID    := replace(aggregations/LAU2/UniqueZones/ZoneID, '_', '');
			attribute<string> RunAreaId := replace_value(left(ZoneID, 2), 'EL', 'GR', 'BE', 'BELUX', 'LU', 'BELUX', 'CH', 'CZ');
		}
		unit<uint32> NUTS3_EuroStat     := src/NUTS3_EuroStat/inFile;
	}
	
	container relational
	{
		attribute<Regions/Runs> base_zones         (Regions/base_zones)             := rlookup(Regions/base_zones/RunAreaId, Regions/Runs/ZoneId);
		attribute<Regions/Runs> ForestDemandRegions(LUISA_zones/ForestDemandRegions):= point_in_polygon(centroid_or_mid(LUISA_zones/ForestDemandRegions/Geometry),	Regions/Runs/Geometry);
		attribute<Regions/Runs> Capri              (Regions/Capri)                  := point_in_polygon(centroid_or_mid(Regions/Capri/Geometry),			       Regions/Runs/Geometry);
		attribute<Regions/Runs> RunAreas           (LUISA_zones/RunAreas)           := point_in_polygon(centroid_or_mid(LUISA_zones/RunAreas/Geometry),	Regions/Runs/Geometry);
		attribute<Regions/Runs> LAU2_adm(Regions/LAU2)  := rlookup(BoundaryDomains/LAU2/RunAreaId, Regions/Runs/ZoneId);
		attribute<Regions/Runs> LAU2    (Regions/LAU2)  := LAU2_adm;
		attribute<bool> geo_issue(Regions/LAU2) := IsDefined(LAU2_adm) && !IsDefined(LAU2_geo);
		attribute<bool> adm_issue(Regions/LAU2) := IsDefined(LAU2_geo) && !IsDefined(LAU2_adm);
		
		attribute<Regions/Runs> NUTS0_LUISA(BoundaryDomains/NUTS0_LUISA):
			 = point_in_polygon(centroid_or_mid(BoundaryDomains/NUTS0_LUISA/Geometry), Regions/Runs/Geometry);
			
		attribute<Regions/Runs> NUTS1_LUISA(BoundaryDomains/NUTS1_LUISA):
			 = point_in_polygon(centroid_or_mid(BoundaryDomains/NUTS1_LUISA/Geometry), Regions/Runs/Geometry);
			
		attribute<Regions/Runs> NUTS2_merged_LUISA(BoundaryDomains/NUTS2_merged_LUISA):
			 = point_in_polygon(centroid_or_mid(BoundaryDomains/NUTS2_merged_LUISA/Geometry), Regions/Runs/Geometry);
			
		attribute<Regions/Runs> NUTS2_LUISA(BoundaryDomains/NUTS2_LUISA):
			 = point_in_polygon(centroid_or_mid(BoundaryDomains/NUTS2_LUISA/Geometry), Regions/Runs/Geometry);
			
		attribute<Regions/Runs> NUTS3_LUISA(BoundaryDomains/NUTS3_LUISA):
			 = point_in_polygon(centroid_or_mid(BoundaryDomains/NUTS3_LUISA/Geometry), Regions/Runs/Geometry);
			
		attribute<Regions/Runs> LAU2_geo(BoundaryDomains/LAU2):
			 = point_in_polygon(centroid_or_mid(BoundaryDomains/LAU2/Geometry), Regions/Runs/Geometry);
			
		attribute<Regions/Runs> NUTS3_EuroStat(BoundaryDomains/NUTS3_EuroStat):
			 = point_in_polygon(centroid_or_mid(BoundaryDomains/NUTS3_EuroStat/Geometry), Regions/Runs/Geometry);
	}
	
	container RegionGrids := for_each_nedvn(BoundarySets/uniName
	,	'poly2grid(BoundaryDomains/'+ BoundarySets/uniName +'/Geometry, Lambert100mGrid)'
	,	Lambert100mGrid, BoundaryDomains, BoundarySets/uniName
	)
	{
		attribute<uint32> base_raster (Lambert100mGrid): StorageName = "%EUCS_100mDir%/zones/LAU2_raster.tif", StorageType = "gdal.grid", StorageReadOnly = "True";
	}
	
	
	container LUISA_zones
	{
		unit<uint32> Nuts1 := src/NUTS1_LUISA/inFile
		{
			attribute<CountryTable> CT_id: 		expr = "rlookup(Itl_Code, CountryTable/N0Code)";
			attribute<string> 		Itl_Code:	expr = "substr(replace(ZoneId, 'EL', 'GR'), 0, 2)";
			attribute<string>		LUISA_Code: expr = "CountryTable/LUISACode[CT_id]";
			attribute<string> 		Label:		expr = "CountryTable/ItlName[CT_id]";
			attribute<string>		LUISAName:	expr = "CountryTable/LUISAName[CT_id]";
			attribute<bool>			Exclude:	expr = "ZoneId = 'PT2' || ZoneId = 'PT3' || ZoneId = 'ES7' || ZoneId = 'FRA' || ZoneId = 'FR9'"; // exclude atlantic islands of PT and ES
			attribute<bool>			Sel:		expr = "CountryTable/LUISAsel[CT_id] && !Exclude";
		}
		unit<uint32> RunN1s := subset(Nuts1/Sel)
		{
			attribute<LambertEA> 	Geometry (polygon): expr = "Nuts1/Geometry[Nr_OrgEntity]";
			attribute<string> 		Code:				expr = "Nuts1/LUISA_Code[Nr_OrgEntity]";
			attribute<string> 		Label:				expr = "Nuts1/Label[Nr_OrgEntity]";
			attribute<string> 		Name:				expr = "Nuts1/LUISAName[Nr_OrgEntity]";
			attribute<RunAreas>		RunAreaId:			expr = "rlookup(Name, RunAreas/Values)";
			attribute<string> 		ForestDemandCode:	expr = "Code = 'BELUX' ? Code : Nuts1/Itl_Code[Nr_OrgEntity]";
			attribute<string> 		ForestDemandName:	expr = "Code = 'BELUX' ? Name : Label";
			attribute<ForestDemandRegions> ForestDemandId: expr = "rlookup(ForestDemandName, ForestDemandRegions/Values)";
		}
		unit<uint32> outsideRun := subset(!Nuts1/Sel)
		{
			attribute<LambertEA> 	Geometry (polygon) := Nuts1/Geometry[Nr_OrgEntity];
			attribute<string> 		Code := Nuts1/LUISA_Code[Nr_OrgEntity];
			attribute<string> 		Label:= Nuts1/Label[Nr_OrgEntity];
			attribute<string> 		Name := Nuts1/LUISAName[Nr_OrgEntity];
		}
		unit<uint32> RunAreas := Unique(RunN1s/Name)
		{
			attribute<LambertEA> Geometry (poly) := partitioned_union_polygon(RunN1s/Geometry[ipoint], RunN1s/RunAreaId)[LambertEA];
			attribute<string> 	 Name            := Values;
			attribute<string> 	 ICC             := first(RunN1s/Code, RunN1s/RunAreaId);
			attribute<string>	 ZoneId          := ICC;
			attribute<string>	 Nuts_code       := ICC;
			attribute<String>    N0CD:           	expr = "ICC";
		}
		unit<uint32> ForestDemandRegions := Unique(RunN1s/ForestDemandName)
		{
			attribute<LambertEA> Geometry (poly) := partitioned_union_polygon(RunN1s/Geometry[ipoint], RunN1s/ForestDemandId)[LambertEA];
			attribute<string> 	 Name:				expr = "Values";
			attribute<string>	 ZoneId:			expr = "ICC";
			attribute<string>	 Nuts_code:			expr = "ICC";
			attribute<String>    N0CD:           	expr = "ICC";
			attribute<string> 	 ICC:				expr = "first(RunN1s/ForestDemandCode, RunN1s/ForestDemandId)";
		}
	}
	
	parameter<uint32> NrN0Zones: expr = "56";
	parameter<uint32> NrN0Attributes: expr = "5";
	
	unit<uint32> CountryTable: expr = "range(uint32, 0, NrN0Zones)"
	{
		
		attribute<string> N0Code: 		expr = "inElements/elements[((id(.)*NrN0Attributes)+0)[inElements]]";
		attribute<string> LUISACode:	expr = "inElements/elements[((id(.)*NrN0Attributes)+1)[inElements]]";
		attribute<string> ItlName: 		expr = "inElements/elements[((id(.)*NrN0Attributes)+2)[inElements]]";
		attribute<string> LUISAName:	expr = "inElements/elements[((id(.)*NrN0Attributes)+3)[inElements]]";
		attribute<bool> LUISAsel: 		expr = "bool(uint32(inElements/elements[((id(.)*NrN0Attributes)+4)[inElements]]))";
		
		unit<uint32> inElements: expr = "range(uint32, 0, NrN0Zones * NrN0Attributes)"
		{
		
			attribute<string> elements: [
				'UK',	'UK', 	'United Kingdom',	'United_Kingdom',	'1',
				'NO',	'NO',	'Norway',	'Norway',	'0',
				'GG',	'UK',	'Guernsey',	'',	'0',
				'ES',	'ES',	'Spain',	'Spain',	'1',
				'MT',	'MT',	'Malta',	'Malta',	'1',
				'GE',	'GE',	'Georgia',	'',	'0',
				'TR',	'TR',	'Turkey',	'',	'0',
				'ND',	'UK',	'United Kingdom',	'United_Kingdom',	'1',
				'AT',	'AT',	'Austria',	'Austria',	'1',
				'VA',	'VA',	'Vatican city',	'',	'0',
				'HU',	'HU',	'Hungary',	'Hungary',	'1',
				'RO',	'RO',	'Romania',	'Romania',	'1',
				'SE',	'SE',	'Sweden',	'Sweden',	'1',
				'LU',	'BELUX',	'Luxembourg',	'BelgLux',	'1',
				'LI',	'LI',	'Liechtenstein',	'',	'0',
				'BY',	'BY',	'Belarus',	'',	'0',
				'MD',	'MD',	'Moldovia',	'',	'0',
				'FO',	'DK',	'Faroe Islands',	'',	'0',
				'DK',	'DK',	'Denmark',	'Denmark',	'1',
				'GI',	'UK',	'Gibraltar',	'',	'0',
				'BE',	'BELUX',	'Belgium',	'BelgLux',	'1',
				'GR',	'GR',	'Greece',	'Greece',	'1',
				'SK',	'SK',	'Slovakia',	'Slovakia',	'1',
				'RU',	'RU',	'Russia',	'',	'0',
				'CY',	'CY',	'Cyprus',	'Cyprus',	'1',
				'JE',	'UK',	'Jersey',	'',	'0',
				'CZ',	'CZ',	'Czech Republic',	'Czechia',	'1',
				'IM',	'UK',	'Isle of Man',	'',	'0',
				'UA',	'UA',	'Ukraine',	'',	'0',
				'GB',	'UK',	'United Kingdom',	'United_Kingdom',	'1',
				'EE',	'EE',	'Estonia',	'Estonia',	'1',
				'PT',	'PT',	'Portugal',	'Portugal',	'1',
				'AD',	'AD',	'Andorra',	'',	'0',
				'LV',	'LV',	'Latvia',	'Latvia',	'1',
				'SM',	'SM',	'San Marino',	'',	'0',
				'BG',	'BG',	'Bulgaria',	'Bulgaria',	'1',
				'LT',	'LT',	'Lithuania',	'Lithuania',	'1',
				'IE',	'IE',	'Ireland',	'Ireland',	'1',
				'CH',	'CH',	'Swiss',	'',	'0',
				'GL',	'DK',	'Greenland',	'',	'0',
				'FI',	'FI',	'Finland',	'Finland',	'1',
				'PL',	'PL',	'Poland',	'Poland',	'1',
				'IS',	'IS',	'Iceland',	'',	'0',
				'MC',	'MC',	'Monaco',	'',	'0',
				'AL',	'AL',	'Albania',	'',	'0',
				'BA',	'BA',	'Bosnia and Herzegovina',	'Balkans',	'0',
				'ME',	'ME',	'Montenegro',	'Balkans',	'0',
				'NL',	'NL',	'Netherlands',	'Netherlands',	'1',
				'HR',	'HR',	'Croatia',	'Croatia',	'1',
				'FR',	'FR',	'France',	'France',	'1',
				'DE',	'DE',	'Germany',	'Germany',	'1',
				'MK',	'MK',	'Macedonia',	'',	'0',
				'IT',	'IT',	'Italy',	'Italy',	'1',
				'SI',	'SI',	'Slovenia',	'Slovenia',	'1',
				'KS',	'KS',	'Kosovo',	'',	'0',
				'RS',	'RS',	'Serbia',	'Balkans',	'0'];
		}
	}
	
	
	
	template doLoadFiles
	{
		parameter<string> path;
		parameter<string> IDfield;
		parameter<string> Labelfield;
		
		unit<uint32> inFile: StorageName = "= '%LuisettaDataDir%/zones/' + path + '.shp'", StorageType = "gdal.vect", StorageReadOnly = "True"
		{
			attribute<LambertEA> Geometry (polygon);
			attribute<Float64>   Area  := Area(Geometry, Float64);
			attribute<string> 	 autoID:= 'z_' + string(id(.));
			attribute<string> 	 ZoneID:=  = strlen(IDfield)    = 0 ? 'autoID' : IDfield;	
			attribute<string> 	 Label :=  = strlen(Labelfield) = 0 ? 'ZoneId' : Labelfield;
		}
	}
	template doAggregateSets
	{
		unit<uint32> regions1;
		unit<uint32> regions2;
		
		unit<uint32> mergeUnit := union_unit(regions1, regions2)
		{
			attribute<LambertEA> Geometry (polygon) := union_data(., regions1/Geometry, regions2/Geometry);
			attribute<string> 	 ZoneId             := union_data(., regions1/ZoneId,   regions2/ZoneId);
			attribute<string>  	 Label              := union_data(., regions1/Label,    regions2/Label);
			
			attribute<UniqueZones> uz_rel := rlookup(ZoneId, UniqueZones/Values);
		}
		
		
		unit<uint32> UniqueZones := unique(mergeUnit/ZoneID)
		{
			attribute<LambertEA> 	Geometry (polygon) := partitioned_union_polygon(value(mergeUnit/Geometry, ipoint), mergeUnit/uz_rel)[LambertEA];
			attribute<string> 		ZoneID := Values;
			attribute<string> 		Code   := Values;
			attribute<string> 		Label  := AsList(mergeUnit/Label, ',', mergeUnit/uz_rel);
			attribute<LambertEA>    centroid: expr = "centroid_or_mid(Geometry)"; // REMOVE !!
			attribute<float32>		km2 := float32(area(Geometry, float64)) / float32(1000*1000);
		}
	}	
	template unionZones
	{
		container inSet;
		parameter<string> addLink: expr = "''";
		
		unit<uint32> singleUnit: expr = "inSet/inFile"; 
		
		unit<uint32> mergeUnit:	expr = "= 'union_unit(singleUnit, src/'+ addLink +'/inFile)'"
		{
			attribute<LambertEA> Geometry (polygon): expr = "= 'union_data(., singleUnit/Geometry, src/'+ addLink +'/inFile/Geometry)'";
			attribute<string> 	 ZoneId:			 expr = "= 'union_data(., singleUnit/ZoneId, src/'+ addLink +'/inFile/ZoneId)'";
			attribute<string>  	 Label:				 expr = "= 'union_data(., singleUnit/Label, src/'+ addLink +'/inFile/Label)'";
		}
		
		unit<uint32> inUnit: expr = "= strlen(addLink) > 0 ? 'mergeUnit' : 'singleUnit'" {attribute<UniqueZones> uz_id: expr = "rlookup(ZoneId, UniqueZones/Values)";}
		
		
		unit<uint32> UniqueZones: expr = "unique(inUnit/ZoneID)", DialogData = "Geometry", DialogType  ="map"
		{
			attribute<LambertEA> 	Geometry (polygon): expr = "partitioned_union_polygon(value(inUnit/Geometry, ipoint), inUnit/uz_id)[LambertEA]";
			attribute<string> 		ZoneID:				expr = "Values";
			attribute<string> 		Code:				expr = "Values";
			attribute<string> 		Label:				expr = "first(inUnit/Label, inUnit/uz_id)";
			attribute<LambertEA> centroid: expr = "centroid_or_mid(Geometry)";
			attribute<float32>		km2: 				expr = "float32(area(Geometry, float64)) / float32(1000*1000)";
		}
	}	
}