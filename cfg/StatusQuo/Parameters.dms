container Parameters: KeepData = "True", Using = "Units"
{
	unit<Float32> YearRange: Expr = "Units/YearRange";
	unit<Float32> YearDiffRange: Expr = "Units/YearDiffRange";
	container PeriodSet
	{
	
		parameter<YearRange> StartYear: [2018]
		,	ParamType = "Numeric"
		,	ParamData = "YearRange";
			
		parameter<YearRange> SpoofStartYear: [2015] // to ensure that result has necessary number of rows
		,	ParamType = "Numeric"
		,	ParamData = "YearRange";
		
		
		parameter<YearRange> EndYear:  [2050]
		,	ParamType = "Numeric"
		,	ParamData = "YearRange";
	
		parameter<YearDiffRange> TimeStep: [ 5.0 ] // can also be [0.25] // [ 0.5] // [ 0.1 ] 
		,	ParamType = "Numeric"
		,	ParamData = "YearDiffRange"
		,	Descr     = "Periodelengte (in jaren)";
		
		unit<UInt16> result := Range(UInt16, UInt16(0), UInt16( (EndYear - SpoofStartYear) / TimeStep))
		{
			attribute<YearDiffRange> PeriodLength := id(result) > uint16(0) ? 5.0[YearDiffRange] : 2.0[YearDiffRange];
			attribute<YearDiffRange> YearsPast    := cumulate(PeriodLength);
			attribute<YearRange> CurrYear         := StartYear + MakeDefined(YearsPast[sub_or_null(Id(.), 1w)], 0f);
			attribute<YearRange> ProjectedYear:		Expr = "CurrYear + PeriodLength";
			attribute<String>  YearStr: Expr = "String(ProjectedYear)";
			attribute<String>  IdStr: Expr = "'UInt16('+String(ID(.))+')'";
			attribute<String>  Name:  Expr = "'P'+Replace(YearStr,'.','_')";
			attribute<string>  Label := YearStr, DialogType = "LabelText";
			
			attribute<Float32> ClaimFraction: Expr = "Float32(CurrYear - StartYear)/Float32(EndYear - StartYear)"; // "Float32(PeriodLength)*Float32(CurrYear - StartYear)/Float32(EndYear - StartYear)";
			attribute<String>  ClaimFractionStr: Expr = "'value('+String(ClaimFraction)+',Float32)'";
			attribute<String>  PrevRef := MakeDefined(Name[sub_or_null(ID(.), 1w)]+'/ResultingState', 'StartingState');
			unit<UInt16> Decennium: Expr = "../Decennium";
			unit<UInt16> Lustrum: Expr = "../Lustrum";
			parameter<String> BaseYearCorineDataFileName: Expr = "'%LuisettaDataDir%/landuse/CLC12_Land_Cover_Adj_Poly.tif'"; 
			container V := for_each_nedv(name, string(ID(.))+'[..]', void, .);
		}
		unit<UInt16> Decennium: NrOfRows = 5
		{
			attribute<result> Year:     [ /*'2006',*/ 2010, 2020, 2030, 2040, 2050 ];
			attribute<result> PrevYear: [             2006, 2010, 2020, 2030, 2040 ];
			
			attribute<String> YearStr: Expr = "String(Year)";
			attribute<String> Label: Expr = "YearStr";
			attribute<String> Name: Expr = "'P'+YearStr";
			attribute<String> YearName: Expr = "'Yr'+YearStr";
			
			attribute<result> RefPeriod: Expr = "max_elem(UInt16(ID(.))*UInt16(10), UInt16(1))";
			attribute<String> DynamicExt: Expr = "String(RefPeriod)";
			
			attribute<.>      StartingYear: Expr = "MakeDefined(ID(.)-1[.], 0[.])";
			attribute<.>      EndingYear:   Expr = "replace_value(ID(.), 0[.], last(ID(.)))";
			attribute<String> PeriodName:   Expr = "'P'+YearStr[StartingYear]+'_P'+YearStr[EndingYear]";
		}
		unit<UInt16> Lustrum: NrOfRows = 9
		{
			attribute<result> Year:     [ 2010, 2015, 2020, 2025, 2030, 2035, 2040, 2045, 2050 ];
			attribute<result> PrevYear: [ 2006, 2010, 2015, 2020, 2025, 2030, 2035, 2040, 2045 ];
			
			attribute<String> YearStr: Expr = "String(Year)";
			attribute<String> Label: Expr = "YearStr";
			attribute<String> Name: Expr = "'P'+YearStr";
			attribute<String> YearName: Expr = "'Yr'+YearStr";
			
			// Lustrum Periods with first period ranging over all periods.
			attribute<.> StartingYear: Expr = "MakeDefined(ID(.)-1[.], 0[.])";
			attribute<.> EndingYear:   Expr = "replace_value(ID(.), 0[.], last(ID(.)))";
			attribute<String>  PeriodName:   Expr = "'P'+YearStr[StartingYear]+'_P'+YearStr[EndingYear]";
		}
	}
	container FuncKernels
	{
		unit<SPoint> ReciprocalRevolution10km: Expr = "range(spoint, point(int16(-100), int16(-100)), point(int16(101), int16(101)))", Descr = "revolution around origin of of z=1/r up to 10 km "
		{
			attribute<UInt32>  Dist2: Expr = "Dist2(point(Int16(0), Int16(0), .), uint32)"; // Sqare distance to origin (= cell with row=0 and col=0) in raster cell units.
			attribute<Float64> Attr : Expr = "(Dist2 > 0  && Dist2 <= (100*100)) ? (1.0 / Sqrt(Dist2)) : 0.0"; //
			attribute<Float32> Matr : Expr = "scalesum(Float32(Attr), Float32(1.0))"; // divides Attr by the sum of Attr so that the sum of Matr equals 1.
		}
		
		unit<SPoint> Cylinder500m: Expr = "range(spoint, point(int16(-5), int16(-5)), point(int16(6), int16(6)))", Descr = "cylinder of 500m radius, excluding self interaction"
		{
			attribute<UInt32>  Dist2: Expr = "Dist2(point(Int16(0), Int16(0), .), uint32)"; // Sqare distance to origin (= cell with row=0 and col=0) in raster cell units.
			attribute<Float64> Attr : Expr = "Float64(Dist2 > 0  && Dist2 <= (5*5))"; //
			attribute<Float32> Matr : Expr = "scalesum(Float32(Attr), Float32(1.0))"; // divides Attr by the sum of Attr so that the sum of Matr equals 1.
		}
		unit<SPoint> Cylinder5km: Expr = "range(spoint, point(int16(-50), int16(-50)), point(int16(51), int16(51)))", Descr = "cylinder of 5km radius, excluding self interaction"
		{
			attribute<UInt32>  Dist2: Expr = "Dist2(point(Int16(0), Int16(0), .), uint32)"; // Sqare distance to origin (= cell with row=0 and col=0) in raster cell units.
			attribute<Float64> Attr : Expr = "Float64(Dist2 > 0  && Dist2 <= (50*50))"; //
			attribute<Float32> Matr : Expr = "scalesum(Float32(Attr), Float32(1.0))"; // divides Attr by the sum of Attr so that the sum of Matr equals 1.
		}
		unit<SPoint> LinearDecay1km: Expr = "range(spoint, point(int16(-10), int16(-10)), point(int16(11), int16(11)))", Descr = "linear distance decay until 2 km"
		{
			attribute<UInt32>  Dist2: Expr = "Dist2(point(Int16(0), Int16(0), .), uint32)"; // Sqare distance to origin (= cell with row=0 and col=0) in raster cell units.
			attribute<Float64> Attr : Expr = "(Dist2 > 0  && Dist2 <= (10*10)) ? 10.0 - Sqrt(Dist2) : 0.0"; //
			attribute<Float32> Matr : Expr = "scalesum(Float32(Attr), Float32(1.0))"; // divides Attr by the sum of Attr so that the sum of Matr equals 1.
		}
		unit<SPoint> LinearDecay2km: Expr = "range(spoint, point(int16(-20), int16(-20)), point(int16(21), int16(21)))", Descr = "linear distance decay until 2 km"
		{
			attribute<UInt32>  Dist2: Expr = "Dist2(point(Int16(0), Int16(0), .), uint32)"; // Sqare distance to origin (= cell with row=0 and col=0) in raster cell units.
			attribute<Float64> Attr : Expr = "(Dist2 > 0  && Dist2 <= (20*20)) ? 20.0 - Sqrt(Dist2) : 0.0"; //
			attribute<Float32> Matr : Expr = "scalesum(Float32(Attr), Float32(1.0))"; // divides Attr by the sum of Attr so that the sum of Matr equals 1.
		}
		unit<Spoint> LinearDecay5km: Expr = "range(spoint, point(int16(-50), int16(-50)), point(int16(51), int16(51)))", Descr = "linear distance decay until 2 km"
		{
			attribute<UInt32>  Dist2: Expr = "Dist2(point(Int16(0), Int16(0), .), uint32)"; // Sqare distance to origin (= cell with row=0 and col=0) in raster cell units.
			attribute<Float64> Attr : Expr = "(Dist2 > 0  && Dist2 <= (50*50)) ? 50.0 - Sqrt(Dist2) : 0.0"; //
			attribute<Float32> Matr : Expr = "scalesum(Float32(Attr), Float32(1.0))"; // divides Attr by the sum of Attr so that the sum of Matr equals 1.
		}
		unit<SPoint> km10_neighbours: Expr = "range(spoint, point(int16(-100), int16(-100)), point(int16(101), int16(101)))", Descr = "10km neighbours"
		{	
			attribute<Float32>  Dist2: Expr = "float32(sqrt(Dist2(point(Int16(0), Int16(0), .), uint32)))"; // Sqare distance to origin (= cell with row=0 and col=0) in raster cell units.
			attribute<Float32> Matr : Expr = "float32(1) / (Dist2)"; // divides Attr by the sum of Attr so that the sum of Matr equals 1.
		}
		unit<Spoint> LinearDecay10km: Expr = "range(spoint, point(int16(-100), int16(-100)), point(int16(101), int16(101)))", Descr = "linear distance decay until 2 km"
		{
			attribute<UInt32>  Dist2: Expr = "Dist2(point(Int16(0), Int16(0), .), uint32)"; // Sqare distance to origin (= cell with row=0 and col=0) in raster cell units.
			attribute<Float64> Attr : Expr = "(Dist2 > 0  && Dist2 <= (100*100)) ? 100.0 - Sqrt(Dist2) : 0.0"; //
			attribute<Float32> Matr : Expr = "scalesum(Float32(Attr), Float32(1.0))"; // divides Attr by the sum of Attr so that the sum of Matr equals 1.
		}
				
		unit<SPoint> ExponentialDecay7km: Expr = "range(spoint, point(int16(-70), int16(-70)), point(int16(71), int16(71)))", Descr = "linear distance decay until 7 km"
		{
			attribute<UInt32>  Dist2: Expr = "Dist2(point(Int16(0), Int16(0), .), uint32)"; // Sqare distance to origin (= cell with row=0 and col=0) in raster cell units.
			attribute<Float64> Attr : Expr = "(Dist2 > 0  && Dist2 <= (70*70)) ? Exp(-Sqrt(Dist2) / 35.0 ) : 0.0"; //
			attribute<Float32> Matr : Expr = "scalesum(Float32(Attr), Float32(1.0))"; // divides Attr by the sum of Attr so that the sum of Matr equals 1.
		}
		unit<SPoint> RooksNeighbours: Expr = "range(spoint, point(int16(-1), int16(-1)), point(int16(2), int16(2)))", Descr = "Rooks case contiguous neighbours (only direct)"
		{	
			attribute<UInt32>  Dist2: Expr = "Dist2(point(Int16(0), Int16(0), .), uint32)"; // Sqare distance to origin (= cell with row=0 and col=0) in raster cell units.
			attribute<Float64> Attr : Expr = "float64(Dist2 > 0  && Dist2 <= (1))"; //
			attribute<Float32> Matr : Expr = "scalesum(Float32(Attr), Float32(1.0))"; // divides Attr by the sum of Attr so that the sum of Matr equals 1.
		}
 		unit<SPoint> QueensNeighbours: Expr = "range(spoint, point(int16(-1), int16(-1)), point(int16(2), int16(2)))", Descr = "Queens case contiguous neighbours (only direct)"
		{	
			attribute<UInt32>  Dist2: Expr = "Dist2(point(Int16(0), Int16(0), .), uint32)"; // Sqare distance to origin (= cell with row=0 and col=0) in raster cell units.
			attribute<Float64> Attr : Expr = "float64(Dist2 > 0  && Dist2 <= (2))"; //
			attribute<Float32> Matr : Expr = "scalesum(Float32(Attr), Float32(1.0))"; // divides Attr by the sum of Attr so that the sum of Matr equals 1.
		}

	    unit<spoint>  Area1km2: expr =    "range(spoint,point(-int16(5), -int16(5)), point(int16(6), int16(6)))", Descr = "kernel with an area of approximately 1 km2"
  		 {
   		   attribute<uint32> distMatr:  expr = "dist2(point(int16(0), int16(0), .), uint32)";
      	   attribute<Float32> AbsWeight: expr =  "distMatr <=uint32(36) ? Float32(1.0) : Float32(0.0)";
   		 } 
   		 			
		unit<UInt8> Set: Expr = "range(UInt8, UInt8(0), UInt8(4))" // @USERINPUT
		{
			attribute<String> Name:    [ 'ReciprocalRevolution10km', 'Cylinder5km', 'LinearDecay2km', 'ExponentialDecay7km'] ;
			attribute<String> MatrRef: Expr = "'FuncKernels/'+Name";
		}
		
	}
	container Templ
	{
		container ManageDemandModelParams: IsTemplate = "True", Using = "MetaData"
		{
			parameter<DemandModelsList> ModelId;
			
			container ZoneSets: expr = "Templ/getDemandModelParams(Meta/Run, ModelId)";
			
			container TableChopper: expr = "ZoneSets/TableChopper";
			
			unit<uint32> FactorReferences: expr = "TableChopper/Field";
			
			container ParameterSet: expr = "for_each_nedv(FactorReferences/FactorName, 'value(TableChopper/Data/'+ TableChopper/Field/FactorName +', float32)[TableChopper/ZoneId]',Meta/Run,float32)"
			{	
				attribute<float32> 			Constant (Meta/Run): expr = "TableChopper/Constant"; 
				attribute<float32>			Rho		 (Meta/Run): expr = "TableChopper/Rho"; 
				attribute<Meta/Run>			ZoneId	 (Meta/Run): expr = "id(Meta/Run)";
			}
			Container genExpressions: expr = "for_each_ne(Meta/Run/Name, 'Templ/arrange'+ DemandModelsList/arranging_template[ModelId] +'(' + string(id(Meta/Run)) + ', MetaData/DemandModelFactors, ParameterSet)' )";
		}
		Container getExogenousParams: IsTemplate = "True"
		{
			
			unit<uint32> 								UnitRef; // :		expr = "Meta/Alloc1Set/UniqueFiles";
			parameter<Classifications/LU/ModelType> 	LandUseNr; //: 	expr = "'Urban'";
			unit<uint16>								RunsRef:	expr = "Meta/Run";
			
			unit<uint32> Factors: 					expr = "MetaData/FactorID";
			
			//attribute<string> DefExpression (UnitRef): expr = "TableChopper/Constant + ' + ' + TableChopper/Params";
			
			container TableChopper
			{
			   parameter<String> FileName:       	expr = "ParamSets/ActiveSet/ParamPath + '/ExogenousParams/' + Classifications/LU/ModelType/Name[LandUseNr] +'_weights.csv'";
			   unit<uint32>      Domain:  			expr = "UnitRef";
			   //unit<uint32>      Domain; //  			expr = "range(uint16, uint16(0), uint16(#Geography/Regions/Nuts0_v10))";
			   
			   parameter<String> FieldSeparator: 	expr = "';'";
			
			   parameter<String> FileData
			   :  StorageType = "str"
			   ,  StorageName = "=FileName";
			   parameter<String> HeaderLine: expr = "readLines(FileData, void, 0)";
			   parameter<Bool>   HeaderOK:   expr = "regex_match(HeaderLine,'\"[^\"]*+\"(;\"[^\"]*+\")*+')";
			        
			   unit<UInt32> Field: expr = "Range(UInt32, 0, strcount(HeaderLine, FieldSeparator)+1)"
			   { 
			   		attribute<String> 		Name: 		Expr = "ReadArray(HeaderLine, Field, String, 0)";
			   		attribute<bool>	  		Factor:		Expr = "id(.) > 1[Field]";
					attribute<Factors> 		FactorRef:	Expr = "MakeDefined(rlookup(Factor ? value(substr(Name, 1, strlen(Name) - 1), uint32) : 65535[uint32], id(Factors)), rlookup(UpperCase(Name), UpperCase(Factors/Name)))";
			   		//attribute<Factors> 		FactorRef:	Expr = "MakeDefined(rlookup(Factor ? value(substr(Name, 1, strlen(Name) - 1), uint32) : 65535[uint32], id(Factors)), rlookup(Name, Factors/Name))";
					attribute<string> 		FactorName:	Expr = "Factors/Name[FactorRef]";
			   }
			   
			   unit<uint32> FactorList: expr = "subset(Field/Factor)" {attribute<string> Name: expr = "Field/Name[Nr_OrgEntity]"; attribute<Factors> FactorRef: expr = "Field/FactorRef[Nr_OrgEntity]";}
			   
			   attribute<String> BodyLines(Domain): expr = "readLines(FileData, Domain, HeaderLine/ReadPos)"; //,  IntegrityCheck = "HeaderOK";
			   attribute<Bool> LinesAreSignedIntegerStringOrEmpy (Domain): expr = 
			      "regex_match(BodyLines,'(-?+[0-9]++|\"[^\"]*+\")?+(;(-?+[0-9]++|\"[^\"]*+\")?+)*+')";
			        
			   container Data := for_each_nedv(Field/Name, 'ReadElems(BodyLines,string,'+MakeDefined(Field/Name[sub_or_null(ID(Field), 1)]+'/ReadPos','const(0,Domain)')+')',Domain,string)
			   {
			   		attribute<Domain> 							id (Domain): expr = "id(Domain)";
			   		attribute<Classifications/LU/ModelType> 	LandUseType	(Domain): expr = "const(LandUseNr, Domain, Classifications/LU/ModelType)";
			   }
			   
			   parameter<string> multiple_unit_ref: expr = "repeat('Domain,', #FactorList)";
			   parameter<string> multiple_zone_ref: expr = "repeat('Data/ZoneName,', #FactorList)";
			   
			   unit<uint32> UnitsFactorBase: expr = "= 'union_unit('+ substr(multiple_unit_ref, 0, strlen(multiple_unit_ref)-1) +')'"
			   {
			   		attribute<RunsRef>		UnitId:						expr = "rlookup(replace_value(ZoneName, 'BELUX', 'BL', 'GR', 'EL'), RunsRef/ICC)";
			   		attribute<FactorList> 	FactorId:					expr = "(id(.) / #UnitRef)[FactorList]";
			   		attribute<Classifications/LU/ModelType> LandUseType:expr = "const(LandUseNr, ., Classifications/LU/ModelType)";
			   		attribute<string> 		ZoneName: 					expr = "= 'union_data(UnitsFactorBase,'+ substr(multiple_zone_ref, 0, strlen(multiple_zone_ref)-1) +')'";
			   		attribute<string> 		Weight: 					expr = "= 'union_data(UnitsFactorBase,'+ AsItemList('Data/' + FactorList/Name) +')'";
			   		attribute<Factors> 		FactorRef:					expr = "FactorList/FactorRef[FactorId]";
			   }
			   unit<uint32> UnitsFactors := subset(IsDefined(UnitsFactorBase/UnitID) && Int32(UnitsFactorBase/Weight) > -99 && Float32(UnitsFactorBase/Weight) <> 0f)
			   {
					attribute<UnitsFactorBase> UnitsFactorBase_rel   := nr_OrgEntity;
			   		attribute<RunsRef>		UnitId                     := UnitsFactorBase_rel->UnitID;					
			   		attribute<FactorList> 	FactorId                   := UnitsFactorBase_rel->FactorId;					
			   		attribute<Classifications/LU/ModelType> LandUseType:= UnitsFactorBase_rel->LandUseType;					
			   		attribute<string> 		ZoneName                   := UnitsFactorBase_rel->ZoneName;					
			   		attribute<string> 		Weight                     := UnitsFactorBase_rel->Weight;					
			   		attribute<Factors> 		FactorRef                  := UnitsFactorBase_rel->FactorRef;					
			   }
			   
			   attribute<Domain> ZoneId 		(RunsRef) := rlookup(RunsRef/ICC, replace_value(Data/ZoneName, 'BELUX', 'BL', 'GR', 'EL'));
			   attribute<float32> Constant 		(RunsRef): expr = "value(Data/Constant, float32)[ZoneId]"; 
			   attribute<Classifications/LU/ModelType> LandUseType (Meta/Run): expr = "const(LandUseNr,Meta/Run,Classifications/LU/ModelType)";
			}
		}
		Container getPopulationParams: IsTemplate = "True"
		{
			
			unit<uint16> 				UnitRef; // :		expr = "Meta/Alloc1Set/UniqueFiles";
			parameter<PopModel> 		ModelSel; //: 	expr = "'Urban'";
			
			unit<uint8> PopModel: NrOfRows = 5
			{attribute<string> type: ['Population_pressure','Population_def_nurb','Population_def_urb_central', 'Population_def_urb_remote', 'residential_density_change']; attribute<string> Label: expr = "type";}
			
			unit<uint32> Factors: 					expr = "MetaData/FactorID";
			
			//attribute<string> DefExpression (UnitRef): expr = "TableChopper/Constant + ' + ' + TableChopper/Params";
			
			container TableChopper
			{
			   parameter<String> FileName:       	expr = "ParamSets/ActiveSet/ParamPath + '/Population/' + PopModel/type[ModelSel] +'.csv'";
			   unit<uint16>      Domain:  			expr = "range(uint16, uint16(0), uint16(#Geography/Regions/Nuts0_v10))"; //UnitRef";
			   parameter<String> FieldSeparator: 	expr = "';'";
			
			   parameter<String> FileData
			   :  StorageType = "str"
			   ,  StorageName = "=FileName";
			   parameter<String> HeaderLine: expr = "readLines(FileData, void, 0)";
			   parameter<Bool>   HeaderOK:   expr = "regex_match(HeaderLine,'\"[^\"]*+\"(;\"[^\"]*+\")*+')";
			        
			   unit<UInt32> Field: expr = "Range(UInt32, 0, strcount(HeaderLine, FieldSeparator)+1)"
			   { 
			   		attribute<String> 		Name: 		Expr = "ReadArray(HeaderLine, Field, String, 0)";
			   		attribute<bool>	  		Factor:		Expr = "id(.) > 1[Field]";
			   		attribute<Factors> 		FactorRef:	Expr = "MakeDefined(rlookup(Factor ? value(substr(Name, 1, strlen(Name) - 1), uint32) : 65535[uint32], id(Factors)), rlookup(Name, Factors/Name))";
					attribute<string> 		FactorName:	Expr = "Factors/Name[FactorRef]";
			   }
			   
			   unit<uint32> FactorList: expr = "subset(Field/Factor)" {attribute<string> Name: expr = "Field/Name[Nr_OrgEntity]"; attribute<Factors> FactorRef: expr = "Field/FactorRef[Nr_OrgEntity]";}
			   
			   attribute<String> BodyLines(Domain): expr = "readLines(FileData, Domain, HeaderLine/ReadPos)"; //,  IntegrityCheck = "HeaderOK";
			   attribute<Bool> LinesAreSignedIntegerStringOrEmpy (Domain): expr = 
			      "regex_match(BodyLines,'(-?+[0-9]++|\"[^\"]*+\")?+(;(-?+[0-9]++|\"[^\"]*+\")?+)*+')";
			        
			   container Data: Expr = "for_each_nedv(Field/Name,'ReadElems(BodyLines,string,'+MakeDefined(Field/Name[ID(Field)-1]+'/ReadPos','const(0,Domain)')+')',Domain,string)"
			   {
			   		attribute<Domain> 							id (Domain): expr = "id(Domain)";
				}
			   
			   parameter<string> multiple_unit_ref: expr = "repeat('UnitRef,', #FactorList)";
			   parameter<string> multiple_zone_ref: expr = "repeat('Data/ZoneName,', #FactorList)";
			   
			   unit<uint32> UnitsFactors: expr = "= 'union_unit('+ substr(multiple_unit_ref, 0, strlen(multiple_unit_ref)-1) +')'"
			   {
			   		attribute<UnitRef>		UnitId:						expr = "rlookup(ZoneName, UnitRef/Code)";
			   		attribute<FactorList> 	FactorId:					expr = "(id(.) / #UnitRef)[FactorList]";
			   		attribute<Classifications/LU/ModelType> LandUseType:expr = "const(LandUseNr, ., Classifications/LU/ModelType)";
			   		attribute<string> 		ZoneName: 					expr = "= 'union_data(UnitsFactors,'+ substr(multiple_zone_ref, 0, strlen(multiple_zone_ref)-1) +')'";
			   		attribute<string> 		Weight: 					expr = "= 'union_data(UnitsFactors,'+ AsItemList('Data/' + FactorList/Name) +')'";
			   		attribute<Factors> 		FactorRef:					expr = "FactorList/FactorRef[FactorId]";
			   }
			   attribute<Domain> ZoneId 		(UnitRef): expr = "rlookup(UpperCase(UnitRef/ICC), UpperCase(Data/ZoneName))";
			   attribute<float32> Constant 		(UnitRef): expr = "value(Data/Constant, float32)[ZoneId]"; 
			}
		}
		Container getDemandModelParams: IsTemplate = "True"
		{
			
			unit<uint16> 				UnitRef; // :		expr = "Meta/Alloc1Set/UniqueFiles";
			parameter<uint8>			modelnumber;
			unit<uint32> Factors: 		expr = "MetaData/DemandModelFactors";
			
			//attribute<string> DefExpression (UnitRef): expr = "TableChopper/Constant + ' + ' + TableChopper/Params";
			
			container TableChopper
			{
			   parameter<String> FileName:       	expr = "ParamSets/ActiveSet/ParamPath + '/DemandModels/' + DemandModelsList/Name[modelnumber] +'.csv'";
			   unit<uint16>      Domain:  			expr = "range(uint16, uint16(0), uint16(#Geography/Regions/Nuts0_v10))"; //UnitRef";
			   parameter<String> FieldSeparator: 	expr = "';'";
			
			   parameter<String> FileData
			   :  StorageType = "str"
			   ,  StorageName = "=FileName";
			   parameter<String> HeaderLine: expr = "readLines(FileData, void, 0)";
			   parameter<Bool>   HeaderOK:   expr = "regex_match(HeaderLine,'\"[^\"]*+\"(;\"[^\"]*+\")*+')";
			        
			   unit<UInt32> Field: expr = "Range(UInt32, 0, strcount(HeaderLine, FieldSeparator)+1)"
			   { 
			   		attribute<String> 		Name: 		Expr = "ReadArray(HeaderLine, Field, String, 0)";
			   		attribute<bool>	  		Factor:		Expr = "id(.) > (DemandModelsList/firstFactor[modelnumber])[Field]";
			   		attribute<Factors> 		FactorRef:	Expr = "MakeDefined(rlookup(Factor ? value(substr(Name, 1, strlen(Name) - 1), uint32) : 65535[uint32], id(Factors)), rlookup(Name, Factors/UniName))";
					attribute<string> 		FactorName:	Expr = "Factors/UniName[FactorRef]";
			   }
			   
			   unit<uint32> FactorList: expr = "subset(Field/Factor)" {attribute<string> Name: expr = "Field/Name[Nr_OrgEntity]"; attribute<Factors> FactorRef: expr = "Field/FactorRef[Nr_OrgEntity]";}
			   
			   attribute<String> BodyLines(Domain): expr = "readLines(FileData, Domain, HeaderLine/ReadPos)"; //,  IntegrityCheck = "HeaderOK";
			   attribute<Bool> LinesAreSignedIntegerStringOrEmpy (Domain): expr = 
			      "regex_match(BodyLines,'(-?+[0-9]++|\"[^\"]*+\")?+(;(-?+[0-9]++|\"[^\"]*+\")?+)*+')";
			        
			   container Data: Expr = "for_each_nedv(Field/Name,'ReadElems(BodyLines,string,'+MakeDefined(Field/Name[ID(Field)-1]+'/ReadPos','const(0,Domain)')+')',Domain,string)"
			   {
			   		attribute<Domain> 							id 			(Domain): expr = "id(Domain)";
					attribute<float32>							Constant	(Domain): expr = "const(float32(0),Domain,float32)"; //placeholder in case of empty field
					attribute<float32>							Rho			(Domain): expr = "const(float32(0),Domain,float32)"; //placeholder in case of empty field
					
				}
			   
			   parameter<string> multiple_unit_ref: expr = "repeat('UnitRef,', #FactorList)";
			   parameter<string> multiple_zone_ref: expr = "repeat('Data/ZoneName,', #FactorList)";
			   
			   unit<uint32> UnitsFactors: expr = "= 'union_unit('+ substr(multiple_unit_ref, 0, strlen(multiple_unit_ref)-1) +')'"
			   {
			   		attribute<UnitRef>		UnitId:						expr = "rlookup(ZoneName, UnitRef/Code)";
			   		attribute<FactorList> 	FactorId:					expr = "(id(.) / #UnitRef)[FactorList]";
			   		attribute<Classifications/LU/ModelType> LandUseType:expr = "const(LandUseNr, ., Classifications/LU/ModelType)";
			   		attribute<string> 		ZoneName: 					expr = "= 'union_data(UnitsFactors,'+ substr(multiple_zone_ref, 0, strlen(multiple_zone_ref)-1) +')'";
			   		attribute<string> 		Weight: 					expr = "= 'union_data(UnitsFactors,'+ AsItemList('Data/' + FactorList/Name) +')'";
			   		attribute<Factors> 		FactorRef:					expr = "FactorList/FactorRef[FactorId]";
			   }
			   attribute<Domain> ZoneId 		(UnitRef): expr = "rlookup(UpperCase(UnitRef/ICC), UpperCase(Data/ZoneName))";
			   attribute<float32> Constant 		(UnitRef): expr = "value(Data/Constant, float32)[ZoneId]"; 
			   attribute<float32> Rho			(UnitRef): expr = "value(Data/Rho, float32)[ZoneId]";
			}
		}
		Container getNeighbourhoodParams: IsTemplate = "True"
		{
			
			unit<uint16> 								UnitRef; 
			parameter<Classifications/LU/ModelType> 	LandUseNr;
			
			unit<uint8> LandUses: 						expr = "Classifications/LU/ModelType";
			
			parameter<uint8> DefaultFuncKernel:			expr = "uint8(0)";
			
			container TableChopper
			{
			   parameter<String> FileName:       	expr = "ParamSets/ActiveSet/ParamPath + '/NeighbourhoodParams/' + Classifications/LU/ModelType/Name[LandUseNr] +'_weights.csv'";
			   unit<uint16>      Domain:  			expr = "UnitRef";
			   parameter<String> FieldSeparator: 	expr = "';'";
			
			   parameter<String> FileData
			   :  StorageType = "str"
			   ,  StorageName = "=FileName";
			   parameter<String> HeaderLine: expr = "readLines(FileData, void, 0)";
			   parameter<Bool>   HeaderOK:   expr = "regex_match(HeaderLine,'\"[^\"]*+\"(;\"[^\"]*+\")*+')";
			        
			   unit<UInt32> Field: expr = "Range(UInt32, 0, strcount(HeaderLine, FieldSeparator)+1)"
			   { 
			   		attribute<String> 		Name: 		Expr = "ReadArray(HeaderLine, Field, String, 0)";
			   		attribute<bool>	  		Factor:		Expr = "id(.) > 1[Field]";
			   		attribute<LandUses> 	FactorRef:	Expr = "rlookup(Factor ? value(substr(Name, 1, strlen(Name) - 1), uint8) : 255[uint8], id(LandUses))";
			   }
			   
			   unit<uint32> FactorList: expr = "subset(Field/Factor)" 
			   {
			   		attribute<string> 	Name: expr = "Field/Name[Nr_OrgEntity]"; 
			   		attribute<LandUses> FactorRef: expr = "Field/FactorRef[Nr_OrgEntity]";
			   }
			   
			   attribute<String> BodyLines(Domain): expr = "readLines(FileData, Domain, HeaderLine/ReadPos)"; //,  IntegrityCheck = "HeaderOK";
			   attribute<Bool> LinesAreSignedIntegerStringOrEmpy (Domain): expr = 
			      "regex_match(BodyLines,'(-?+[0-9]++|\"[^\"]*+\")?+(;(-?+[0-9]++|\"[^\"]*+\")?+)*+')";
			        
			   container Data := for_each_nedv(Field/Name,'ReadElems(BodyLines,string,'+(ID(Field) > 0 ? Field/Name[ID(Field)-min_elem(1, ID(Field))]+'/ReadPos' : 'const(0,Domain)')+')',Domain,string)
			   {
			   		attribute<Domain> 	id 			(Domain): expr = "id(Domain)";
			   		attribute<LandUses> LandUseType	(Domain): expr = "const(LandUseNr, Domain, LandUses)";
			   }
			   
			   parameter<string> multiple_unit_ref: expr = "repeat('UnitRef,', #FactorList)";
			   parameter<string> multiple_zone_ref: expr = "repeat('Data/ZoneName,', #FactorList)";
			   
			   unit<uint32> UnitsFactors := = 'union_unit('+ substr(multiple_unit_ref, 0, strlen(multiple_unit_ref)-1) +')'
			   {
			   		attribute<UnitRef>		UnitId:			expr = "rlookup(ZoneName, UnitRef/Code)";
			   		attribute<LandUses> 	SrcLUT:			expr = "FactorList/FactorRef[value(uint32((id(.) / #UnitRef)), FactorList)]";
			   		attribute<string> 		ZoneName: 		expr = "= 'union_data(UnitsFactors,'+ substr(multiple_zone_ref, 0, strlen(multiple_zone_ref)-1) +')'";
			   		attribute<string> 		Weight: 		expr = "= 'union_data(UnitsFactors,'+ AsItemList('Data/' + FactorList/Name) +')'";
			   		attribute<LandUses>		LandUseType:	expr = "const(LandUseNr, UnitsFactors, LandUses)";
			   		attribute<uint8>		Func:			expr = "const(DefaultFuncKernel, UnitsFactors, uint8)";
			   }
				attribute<float32> Constant 		(UnitRef): expr = "value(Data/Constant, float32)[rlookup(UnitRef/ICC, Data/ZoneName)]";
			}
		}
		Container Alloc1_Weight_Aggregation_Templ: IsTemplate = "True"
		{
			
			unit<uint16> UnitRef;
			parameter<string> LandUseClass;
			
			unit<uint32> Factors: expr = "= 'union_unit('+ AsItemList('Alloc1Sets/' + UnitRef/name + '/RegrData/Data/'+ LandUseClass +'/Factors') +')'"
			{
				attribute<UnitRef>  ZoneId:		expr = "rlookup(ZoneName, UnitRef/Name)";
				attribute<string>	ZoneName:	expr = "= 'union_data(., '+ AsItemList('const('+ quote(UnitRef/name) + ', Alloc1Sets/' + UnitRef/name + '/RegrData/Data/'+ LandUseClass +'/Factors, string)')+')'";
				attribute<float32> 	Weight:		expr = "= 'union_data(., '+ AsItemList('Alloc1Sets/' + UnitRef/name + '/RegrData/Data/'+ LandUseClass +'/Factors/Weight') +')'";
				attribute<uint16> 	FactorNr: 	expr = "= 'union_data(., '+ AsItemList('Alloc1Sets/' + UnitRef/name + '/RegrData/Data/'+ LandUseClass +'/Factors/FactorNr') +')'";
				attribute<UniFctr>	FactorId:	expr = "rlookup(FactorNr, UniFctr/Values)";
			}
			unit<uint32> UniFctr: expr = "unique(Factors/FactorNr)";
			
			container Weights: expr = "for_each_nedv('w' + string(UniFctr/Values), 'sum(float32(Factors/FactorNr = uint16(' + string(UniFctr/Values) + ')) * Factors/Weight, Factors/ZoneId)', UnitRef, float32)"
			{ 
				attribute<string> ZoneName 	(UnitRef): expr = "UnitRef/Name";
				attribute<float32>Constant	(UnitRef): expr = "= 'union_data(UnitRef, '+ AsItemList('Alloc1Sets/' + UnitRef/name + '/RegrData/Data/'+ LandUseClass +'/ConstWeight') + ')'";
				
				container TableComposer
				{
					   unit<uint16> context: expr = "UnitRef";
					   // ExportDomain is a domain unit 
					   parameter<String> Fieldlist:      expr = "= quote('ZoneName;Constant;' + asList('w'+ string(UniFctr/Values), ';'))";
					   parameter<String> FieldSeperator: expr = "';'";
					   parameter<String> FileName:       expr = "ParamSets/ActiveSet/ParamPath + '/ExogenousParams/' + LandUseClass +'_weights.csv'";
					
					   unit<uint32> Field: expr = "range(uint32,0,strcount(Fieldlist,';')+1)"
					   {
					      attribute<string> Name: expr = "ReadArray(FieldList,.,string,0)";
					   }
					   parameter<string> NewLine: expr = "'\n'";
					   parameter<String> Header:  expr = "FieldList";
					   attribute<String> Body (context): expr =
					      "=AsList("
					         "+'String('+Field/Name+')',' + '+Quote(FieldSeperator)+' +'"
					      ")";
					  
					   parameter<String> Result
					   :  expr        = "Header + NewLine + AsList(Body, NewLine)"
					   ,  StorageName = "=FileName"
					   ,  StorageType = "str";
				}	
			}
		}
		
		Container Alloc2_Weight_Aggregation_Templ: IsTemplate = "True"
		{
			
			unit<uint16> UnitRef;
			parameter<string> LandUseClass;
			
			unit<uint32> Factors: expr = "= 'union_unit('+ AsItemList('Alloc2Sets/' + UnitRef/name + '/RegrData/Data/'+ LandUseClass +'/Factors') +')'"
			{
				attribute<UnitRef>  ZoneId:		expr = "rlookup(ZoneName, UnitRef/Name)";
				attribute<string>	ZoneName:	expr = "= 'union_data(., '+ AsItemList('const('+ quote(UnitRef/name) + ', Alloc2Sets/' + UnitRef/name + '/RegrData/Data/'+ LandUseClass +'/Factors, string)')+')'";
				attribute<float32> 	Weight:		expr = "= 'union_data(., '+ AsItemList('Alloc2Sets/' + UnitRef/name + '/RegrData/Data/'+ LandUseClass +'/Factors/Weight') +')'";
				attribute<uint8> 	SrcLUT: 	expr = "= 'union_data(., '+ AsItemList('Alloc2Sets/' + UnitRef/name + '/RegrData/Data/'+ LandUseClass +'/Factors/SrcLUT') +')'";
				attribute<UniLUT>	SrcLUTId:	expr = "rlookup(SrcLUT, UniLUT/Values)";
			}
			unit<uint32> UniLUT: expr = "unique(Factors/SrcLUT)";
			
			container Weights: expr = "for_each_nedv('l' + string(UniLUT/Values), 'sum(float32(Factors/SrcLUT = uint8(' + string(UniLUT/Values) + ')) * Factors/Weight, Factors/ZoneId)', UnitRef, float32)"
			{ 
				attribute<string> ZoneName 	(UnitRef): expr = "UnitRef/Name";
				attribute<float32>Constant	(UnitRef): expr = "= 'union_data(UnitRef, '+ AsItemList('Alloc2Sets/' + UnitRef/name + '/RegrData/Data/'+ LandUseClass +'/ConstWeight') + ')'";
				
				container TableComposer
				{
					   unit<uint16> context: expr = "UnitRef";
					   // ExportDomain is a domain unit 
					   parameter<String> Fieldlist:      expr = "= quote('ZoneName;Constant;' + asList('l'+ string(UniLUT/Values), ';'))";
					   parameter<String> FieldSeperator: expr = "';'";
					   parameter<String> FileName:       expr = "ParamSets/ActiveSet/ParamPath + '/NeighbourhoodParams/' + LandUseClass +'_weights.csv'";
					
					   unit<uint32> Field: expr = "range(uint32,0,strcount(Fieldlist,';')+1)"
					   {
					      attribute<string> Name: expr = "ReadArray(FieldList,.,string,0)";
					   }
					   parameter<string> NewLine: expr = "'\n'";
					   parameter<String> Header:  expr = "FieldList";
					   attribute<String> Body (context): expr =
					      "=AsList("
					         "+'String('+Field/Name+')',' + '+Quote(FieldSeperator)+' +'"
					      ")";
					  
					   parameter<String> Result
					   :  expr        = "Header + NewLine + AsList(Body, NewLine)"
					   ,  StorageName = "=FileName"
					   ,  StorageType = "str";
				}	
			}
		}
				
		template TransitionCostsTempl
		{
			//parameter<string> TransitionCostsFilePath;
			parameter<String> TransitionCostsFile; //:  StorageName = "=TransitionCostsFilePath", StorageType = "str", KeepData = "True";
			
			unit<UInt8>  ModelType: Expr = "Classifications/LU/ModelType";
			unit<UInt32> ModelMatr: Expr = "Classifications/LU/ModelMatr"
			{
				attribute<Float64> TransitionCosts: Expr = "ReadArray(TransitionCostsFile, ModelMatr, Float64, 0)";
			}
			container xTab: Expr = "for_each_nedv(ModelType/Name, 'ModelMatr/TransitionCosts[value(UInt32(ID(ModelType))*#ModelType+'+String(ID(ModelType))+', ModelMatr)]', ModelType, Float64)";
		}
		
		// maximumvalue of 1.5 hardcoded in this script now.
		template TransitionCostsTempl2
		{
			parameter<string> TransitionCostsFilePath;
			parameter<String> TransitionCostsFile:  StorageName = "=TransitionCostsFilePath", StorageType = "str", KeepData = "True";
			
			unit<UInt8>  ModelType: Expr = "Classifications/LU/ModelType";
			unit<UInt32> ModelMatr: Expr = "Classifications/LU/ModelMatr"
			{
				attribute<Float64> TransitionCosts: Expr = "ReadArray(TransitionCostsFile, ModelMatr, Float64, 0)";
			}
			container xTab: Expr = "for_each_nedv(ModelType/Name, 'ModelMatr/TransitionCosts[value(UInt32(ID(ModelType))*#ModelType+'+String(ID(ModelType))+', ModelMatr)]', ModelType, Float64)";
			container pTab: Expr = "for_each_nedv(ModelType/Name, 'xTab/'+ ModelType/Name +'', ModelType, Float64)";
		}
		
		container GrossRevenuesTempl: IsTemplate = "True"
		{
			parameter<string> GrossRevenuesFilePath;
			parameter<String> GrossRevenuesFile:  StorageName = "=GrossRevenuesFilePath", StorageType = "str", KeepData = "True";
			
			unit<UInt8>  ModelType: Expr = "Classifications/LU/ModelType";
			unit<UInt32> ModelMatr: Expr = "Classifications/LU/ModelMatr"
			{
				attribute<Float64> GrossRevenues: Expr = "ReadArray(GrossRevenuesFile, ModelMatr, Float64, 0)";
			}
			container xTab: Expr = "for_each_nedv(ModelType/Name, 'ModelMatr/GrossRevenues[value(UInt32(ID(ModelType))*#ModelType+'+String(ID(ModelType))+', ModelMatr)]', ModelType, Float64)";
			container pTab: Expr = "for_each_nedv(ModelType/Name, 'xTab/'+ ModelType/Name +'', ModelType, Float64)";
		}
		
		container MatrTempl: IsTemplate = "True"
		{
			parameter<string> NeighbFile;
			parameter<UInt32> StartReadPos;
			parameter<Int16> NrCells: Expr = "ReadValue(NeighbFile, Int16, StartReadPos)";
			unit<SPoint> Data: Expr = "range(spoint, point(-NrCells, -NrCells), point(NrCells + int16(1), NrCells + int16(1)))"
			{
				attribute<Float32> Matr: Expr = "ReadArray(NeighbFile, Data, Float32, NrCells/readPos)";
			}
		}
				
		container NeighbTempl: IsTemplate = "True"
		{
			parameter<string> InNeighbFile;
			
			parameter<String> NeighbFile: StorageName = "=InNeighbFile", StorageType = "str", KeepData = "True";
			
			unit<UInt8> LUT: Expr = "Classifications/LU/ModelType";
			
			attribute<Float32> NeWeights(LUT): Expr = "ReadArray(NeighbFile, LUT, Float32, 0)";
			
			parameter<UInt8> NrNeighbFileKernels: Expr = "ReadValue(NeighbFile, UInt8, NeWeights/readPos)";
			
			unit<UInt8> NeighbFileKernelSet: Expr = "range(UInt8, 0[UInt8], NrNeighbFileKernels)"
			{
				attribute<String> Name: Expr = "'K'+String(ID(.))";
				attribute<String> MatrRef: Expr = "'Matr/'+Name+'/Data'";
			}
			container Matr: Expr = 
				"for_each_ne("
					"NeighbFileKernelSet/Name, "
					"'MatrTempl(NeighbFile,'+MakeDefined(NeighbFileKernelSet/Name[ID(NeighbFileKernelSet)-1[NeighbFileKernelSet] ]+'/Data/Matr/readPos', 'NrNeighbFileKernels/readPos')+')')";
					
			container FuncKernels: Expr = "/Parameters/FuncKernels";
			
			unit<UInt8> KernelSet: Expr = "Range(UInt8, uint8(0), uint8(#NeighbFileKernelSet + #FuncKernels/Set))";

			attribute<String> MatrRef(KernelSet): Expr = 
				"MakeDefined("
					"NeighbFileKernelSet/MatrRef[value(ID(KernelSet), NeighbFileKernelSet)], "
					"FuncKernels/Set/MatrRef[value(ID(KernelSet)-UInt8(#NeighbFileKernelSet), FuncKernels/Set)]"
				")";
		}
		
		container UniqueAllocSet: IsTemplate = "True"
		{
			parameter<String> AddPath;
			parameter<String> FileExt;
			
			unit<uint16> Runs: Expr = "GeoGraphy/Regions/Runs";
			
			attribute<String> ParamPath  (Runs): Expr = "ParamSets/ActiveSet/ParamPath + '/' + AddPath + Runs/AllocDirName";
			attribute<String> ParamPathN0(Runs): Expr = "ParamSets/ActiveSet/ParamPath + '/' + AddPath + Runs/AllocDirNameN0";
			attribute<string> FileName   (Runs): Expr = "FullPathName(., ParamPath + FileExt)";
			attribute<string> FileNameN0 (Runs): Expr = "FullPathName(., ParamPathN0 + FileExt)";
			attribute<String> ActualFileNames(Runs): Expr = "='union_data(Runs, '+AsItemList('ExistingFile('+Quote(FileNameN0)+','+Quote(FileName)+')')+')'";
			unit<UInt16> UniqueFiles: Expr = "Unique(ActualFileNames)"
			{
				attribute<Runs> RunRegion:   Expr = "rlookup(Values, FileName  )";
				attribute<Runs> RunRegionN0: Expr = "rlookup(Values, FileNameN0)";
				attribute<String> Name: Expr = "MakeDefined(Runs/AllocDirName[RunRegion], Runs/AllocDirNameN0[RunRegionN0])";
			}
			attribute<String> Name(Runs): Expr = "rjoin(ActualFileNames, UniqueFiles/Values, UniqueFiles/Name)";
		}
		container Alloc1Factor: IsTemplate = "True", isHidden = "True"
		{
			parameter<UInt32> readPos;
			
			parameter<Float32> Weight  : Expr = "ReadValue(AllocData, Float32, readPos)";
			parameter<UInt16>  FactorNr: Expr = "ReadValue(AllocData, UInt16,  Weight/readPos)";
			
			parameter<UInt32> NextValue: Expr = "FactorNr/readPos";
		}
		container Alloc2Factor: IsTemplate = "True", isHidden = "True"
		{
			parameter<UInt32> readPos;
			
			parameter<Float32> Weight: Expr = "ReadValue(AllocData, Float32, readPos)";
			parameter<UInt8>   SrcLUT: Expr = "ReadValue(AllocData, UInt8,   Weight/readPos)";
			parameter<UInt8>   Func  : Expr = "ReadValue(AllocData, UInt8,   SrcLUT/readPos)";
			
			parameter<UInt32> NextValue: Expr = "Func/readPos";
		}
		container Alloc1LUT: IsTemplate = "True", isHidden = "True"
		{
			parameter<UInt32> readPos;
			
			parameter<UInt8>   LUT        : Expr = "ReadValue(AllocData, UInt8,   readPos)";
			parameter<Float32> ConstWeight: Expr = "ReadValue(AllocData, Float32, LUT/readPos)";
			parameter<UInt32>  NrFactors  : Expr = "ReadValue(AllocData, UInt32,  ConstWeight/readPos)";
			unit<UInt32> Factors: Expr = "Range(UInt32, 0, MakeDefined(NrFactors, 0) )"
			{
				attribute<String> Name: Expr = "'F'+String(ID(Factors))";
				attribute<UInt8>  LandUseType:   Expr = "const(LUT, .)";
				attribute<UInt16>  FactorNr:Expr = "=NrFactors > 0 ? 'union_data(., '+asItemList('FactorData/'+Name+'/FactorNr')+')'     : 'const(UInt16(0), .)'";
				attribute<Float32> Weight:  Expr = "=NrFactors > 0 ? 'union_data(., '+asItemList('FactorData/'+Name+'/Weight')+')' : 'const(Float32(0), .)'";
			}
			container FactorData: Expr = "='iterate(Factors/Name, Alloc1Factor, ''NrFactors/readPos'')'"
			{
				parameter<UInt32> lastValue;
			}
			parameter<UInt32> NextValue: Expr = "FactorData/lastValue";
		}
		container Alloc1Templ: IsTemplate = "True"
		{
			parameter<String> AllocData;
			
			container Data: Expr = "iterate(Classifications/LU/ModelType/Name, Alloc1LUT, '0')"
			{
				parameter<UInt32> lastValue;
			}
		}
		container Alloc2LUT: IsTemplate = "True", isHidden = "True"
		{
			parameter<UInt32> readPos;
			
			parameter<UInt8>   LUT        : Expr = "ReadValue(AllocData, UInt8,   readPos)";
			parameter<Float32> ConstWeight: Expr = "ReadValue(AllocData, Float32, LUT/readPos)";
			parameter<UInt32>  NrFactors  : Expr = "ReadValue(AllocData, UInt32,  ConstWeight/readPos)";
			unit<UInt32> Factors: Expr = "Range(UInt32, 0, MakeDefined(NrFactors, 0) )"
			{
				attribute<String> Name: Expr = "'F'+String(ID(Factors))";
				attribute<UInt8>  LandUseType:   Expr = "const(LUT, .)";
				attribute<UInt8>   SrcLUT:  Expr = "=NrFactors > 0 ? 'union_data(., '+asItemList('FactorData/'+Name+'/SrcLUT')+')'     : 'const(UInt8(0), .)'";
				attribute<Float32> Weight:  Expr = "=NrFactors > 0 ? 'union_data(., '+asItemList('FactorData/'+Name+'/Weight')+')' : 'const(Float32(0), .)'";
				attribute<UInt8>   Func:    Expr = "=(NrFactors > 0) ? 'union_data(., '+asItemList('FactorData/'+Name+'/Func')+')'   : 'const(UInt8(0), .)'";
			}
			container FactorData: Expr = "='iterate(Factors/Name, Alloc2Factor, ''NrFactors/readPos'')'"
			{
				parameter<UInt32> lastValue;
			}
			parameter<UInt32> NextValue: Expr = "FactorData/lastValue";
		}
		container Alloc2Templ: IsTemplate = "True"
		{
			parameter<String> AllocData;
			
			container Data: Expr = "iterate(Classifications/LU/ModelType/Name, Alloc2LUT, '0')"
			{
				parameter<UInt32> lastValue;
			}
		}
		container Alloc1ReorderTempl: IsTemplate = "True"
		{
			container AllocData;
			
			unit<UInt16> FactorID:   Expr = "MetaData/FactorID";
			unit<UInt8> ModelType: Expr = "Classifications/LU/ModelType";
			
			unit<UInt32> FactorWeightsOrg: Expr = "='union_unit('+asItemList('AllocData/'+ModelType/Name+'/Factors')+')'"
			{
				attribute<ModelType> LandUseType:
					Expr = "='value(union_data(FactorWeightsOrg, '+asItemList('AllocData/'+ModelType/Name+'/Factors/LandUseType')+'), ModelType)'";
				attribute<FactorID> FactorNr:
					Expr = "='value(union_data(FactorWeightsOrg, '+asItemList('AllocData/'+ModelType/Name+'/Factors/FactorNr')+'), FactorID)'";
				attribute<Float32> Weight:
					Expr = "='union_data(FactorWeightsOrg, '+asItemList('AllocData/'+ModelType/Name+'/Factors/Weight')+')'";
			}
			container Results: StoreData = "True"
			{
				attribute<Float32> ConstWeight(ModelType): Expr = "='union_data(ModelType, '+asItemList('AllocData/'+ModelType/Name+'/ConstWeight')+')'";
				unit<UInt32> FactorWeights: Expr = "Subset(FactorWeightsOrg/Weight <> Float32(0))"
				{
					attribute<String>    Name:        Expr = "'SF_'+String(LandUseType)+'_'+String(FactorNr)"; // assume this uniquely identifies a factor weight.
					attribute<ModelType> LandUseType: Expr = "FactorWeightsOrg/LandUseType[nr_OrgEntity]";
					attribute<Float32>   Weight:      Expr = "FactorWeightsOrg/Weight     [nr_OrgEntity]";
					attribute<FactorID>  FactorNr:    Expr = "FactorWeightsOrg/FactorNr   [nr_OrgEntity]";
				}
			}
		}
		// New setting of allocation params based on new filestructure (tables per landuse) March 2014 Chris Jacobs-Crisioni
		container New_Alloc1ReorderTempl: IsTemplate = "True"
		{
			container AllocData;
			
			unit<Uint32> FactorID:   Expr = "MetaData/FactorID";
			unit<UInt8> ModelType: Expr = "Classifications/LU/ModelType";
			
			unit<Uint32> ConstWeightsOrg := subset(AllocData/Constants/RegionId == inRegionId)
			{	
				attribute<ModelType> 	LandUseType: expr = "AllocData/Constants/LandUseType[nr_OrgEntity]";
				attribute<float32>		Weight:		 expr = "AllocData/Constants/Weight[nr_OrgEntity]";
			}
			unit<UInt32> FactorWeightsOrg: Expr = "subset(AllocData/RegionId = inRegionId)"
			{
				attribute<ModelType> LandUseType: 	expr = "AllocData/LandUseType[Nr_OrgEntity]";
				attribute<FactorID> FactorNr:	  	expr = "AllocData/FactorID[Nr_OrgEntity]";
				attribute<Float32> Weight:			expr = "AllocData/Weight[Nr_OrgEntity]";
			}
			container Results: StoreData = "True"
			{
				attribute<Float32> ConstWeight(ModelType): Expr = "rjoin(id(ModelType), ConstWeightsOrg/LandUseType, ConstWeightsOrg/Weight)";
				unit<UInt32> FactorWeights: Expr = "Subset(FactorWeightsOrg/Weight <> Float32(0))"
				{
					attribute<String>    Name:        Expr = "'SF_'+String(LandUseType)+'_'+String(FactorNr)"; // assume this uniquely identifies a factor weight.
					attribute<ModelType> LandUseType: Expr = "FactorWeightsOrg/LandUseType[nr_OrgEntity]";
					attribute<Float32>   Weight:      Expr = "FactorWeightsOrg/Weight     [nr_OrgEntity]";
					attribute<FactorID>  FactorNr:    Expr = "FactorWeightsOrg/FactorNr   [nr_OrgEntity]";
					attribute<string>	 VariableRef: Expr = "FactorId/VariableRef[FactorNr]";
				}
			}
		}
		container Alloc2ReorderTempl: IsTemplate = "True"
		{
			container AllocData;
			unit<UInt8> ModelType: Expr = "Classifications/LU/ModelType";
			unit<UInt8> Funcs: Expr = "NeighbourhoodLink/KernelSet";
			
			unit<UInt32> FactorWeightsOrg: Expr = "='union_unit('+asItemList('AllocData/'+ModelType/Name+'/Factors')+')'"
			{
				attribute<ModelType> LandUseType: 
					Expr = "='value(union_data(FactorWeightsOrg, '+asItemList('AllocData/'+ModelType/Name+'/Factors/LandUseType')+'), ModelType)'";
				attribute<ModelType> SrcLUT:
					Expr = "='value(union_data(FactorWeightsOrg, '+asItemList('AllocData/'+ModelType/Name+'/Factors/SrcLUT')+'), ModelType)'";
				attribute<Float32> Weight:
					Expr = "='union_data(FactorWeightsOrg, '+asItemList('AllocData/'+ModelType/Name+'/Factors/Weight')+')'";
				attribute<Funcs> Func:
					Expr = "='union_data(FactorWeightsOrg, '+asItemList('AllocData/'+ModelType/Name+'/Factors/Func')+')'";
			}
			container Results: StoreData = "True"
			{
				attribute<Float32> ConstWeight(ModelType): Expr = "='union_data(ModelType, '+asItemList('AllocData/'+ModelType/Name+'/ConstWeight')+')'";
				unit<UInt32> FactorWeights: Expr = "Subset(FactorWeightsOrg/Weight <> Float32(0))"
				{
					attribute<ModelType> LandUseType: Expr = "FactorWeightsOrg/LandUseType[nr_OrgEntity]";
					attribute<Float32>   Weight:      Expr = "FactorWeightsOrg/Weight     [nr_OrgEntity]";
					attribute<ModelType> SrcLUT:      Expr = "FactorWeightsOrg/SrcLUT     [nr_OrgEntity]";
					attribute<Funcs>     Func:        Expr = "FactorWeightsOrg/Func       [nr_OrgEntity]";
					attribute<UInt32>    UFF_key:     Expr = "UInt32(SrcLUT) + UInt32(Func) * #ModelType";
					attribute<UniqueFactorFuncs> UFF_rel: Expr = "rlookup(UFF_key, UniqueFactorFuncs/Values)";
				}
				unit<UInt32> UniqueFactorFuncs: Expr = "Unique(FactorWeights/UFF_key)"
				{
					attribute<UINt32>    Values;
					attribute<ModelType> SrcLUT:      Expr = "value(Values % #ModelType, ModelType)";
					attribute<Funcs>     Func:        Expr = "value(Values / #ModelType, Funcs)";
					
					attribute<string> ggModelIdExpr(ModelType): Expr = "'value('+String(ID(ModelType))+', ModelType)'";
					
					// moved here from Rules since this is independent of the actual run-region, weight or LUT for which this is a factor
					attribute<String> Name:           Expr = "'NE_'+ModelType/Name[SrcLUT]+'_'+String(Func)";
					attribute<string> PotentialExpr:  Expr = "'potential(Float32(PrevState/Landuse_grid=='+ggModelIdExpr[SrcLUT]+'), Neighbourhood/'+NeighbourhoodLink/MatrRef[Func]+'/Matr)[domain/grid_rel]'";
					attribute<string> AreaExpr:       Expr = "'potential(Float32(CaseData/Land/IsInRunRegion), Neighbourhood/'+NeighbourhoodLink/MatrRef[Func]+'/Matr)[domain/grid_rel]'";
					attribute<string> NeighbourExpr:  Expr = "'PotentialData/'+Name +' / '+'AreaData/'+Name";
					attribute<string> MeanEnrichExpr: Expr = "'replace_value(sum(Float32(PrevState/Landuse_grid=='+ggModelIdExpr[SrcLUT]+')) / sum(Float32(CaseData/Land/IsInRunRegion)), Float32(0.0), Float32(9.0))'";
					attribute<string> EnrichmentExpr: Expr = "'MakeDefined(NeighbourData/'+Name +' / MeanEnrichData/'+Name+', Float32(0))'";
				}
			}
		}
		
		// slightly changed to accommodate changes to neighbourhood files March 2014 Chris Jacobs-Crisioni
		container New_Alloc2ReorderTempl: IsTemplate = "True"
		{
			container AllocData;
			unit<UInt8> ModelType: Expr = "Classifications/LU/ModelType";
			unit<UInt8> Funcs: Expr = "NeighbourhoodLink/KernelSet";
			
			unit<Uint32> ConstWeightsOrg:  Expr = "subset(AllocData/Constants/RegionId = inRegionId)"
			{	
				attribute<ModelType> 	LandUseType: expr = "AllocData/Constants/LandUseType[nr_OrgEntity]";
				attribute<float32>		Weight:		 expr = "AllocData/Constants/Weight[nr_OrgEntity]";
			}
			
			unit<UInt32> FactorWeightsOrg := subset(AllocData/RegionId == inRegionId)
			{
				attribute<ModelType> LandUseType: 	Expr = "AllocData/LandUseType[Nr_OrgEntity]";
				attribute<ModelType> SrcLUT:		Expr = "AllocData/SrcLUT[Nr_OrgEntity]";
				attribute<Float32> Weight:			Expr = "AllocData/Weight[Nr_OrgEntity]";
				attribute<Funcs> Func:				Expr = "(AllocData/Func[Nr_OrgEntity])[Funcs]";
			}
			container Results: StoreData = "True"
			{
				attribute<Float32> ConstWeight(ModelType): Expr = "rjoin(id(ModelType), ConstWeightsOrg/LandUseType, ConstWeightsOrg/Weight)";
				unit<UInt32> FactorWeights: Expr = "Subset(FactorWeightsOrg/Weight <> Float32(0) && FactorWeightsOrg/Weight <> -99f)"
				{
					attribute<ModelType> LandUseType: Expr = "FactorWeightsOrg/LandUseType[nr_OrgEntity]";
					attribute<Float32>   Weight:      Expr = "FactorWeightsOrg/Weight     [nr_OrgEntity]";
					attribute<ModelType> SrcLUT:      Expr = "FactorWeightsOrg/SrcLUT     [nr_OrgEntity]";
					attribute<Funcs>     Func:        Expr = "FactorWeightsOrg/Func       [nr_OrgEntity]";
					attribute<UInt32>    UFF_key:     Expr = "UInt32(SrcLUT) + UInt32(Func) * #ModelType";
					attribute<UniqueFactorFuncs> UFF_rel: Expr = "rlookup(UFF_key, UniqueFactorFuncs/Values)";
				}
				unit<UInt32> UniqueFactorFuncs: Expr = "Unique(FactorWeights/UFF_key)"
				{
					attribute<UINt32>    Values;
					attribute<ModelType> SrcLUT:      Expr = "value(Values % #ModelType, ModelType)";
					attribute<Funcs>     Func:        Expr = "value(Values / #ModelType, Funcs)";
					
					attribute<string> ggModelIdExpr(ModelType): Expr = "'value('+String(ID(ModelType))+', ModelType)'";
					
					// moved here from Rules since this is independent of the actual run-region, weight or LUT for which this is a factor
					attribute<String> Name:           Expr = "ModelType/Name[SrcLUT]";
					attribute<string> PotentialExpr:  Expr = "'potential(Float32(PrevState/Landuse_grid=='+ggModelIdExpr[SrcLUT]+'), Neighbourhood/'+NeighbourhoodLink/MatrRef[Func]+'/Matr)[domain/grid_rel]'";
					attribute<string> AreaExpr:       Expr = "'potential(Float32(CaseData/Land/IsInRunRegion), Neighbourhood/'+NeighbourhoodLink/MatrRef[Func]+'/Matr)[domain/grid_rel]'";
					attribute<string> NeighbourExpr:  Expr = "'PotentialData/'+Name +' / '+'AreaData/'+Name";
					attribute<string> MeanEnrichExpr: Expr = "'replace_value(sum(Float32(PrevState/Landuse_grid=='+ggModelIdExpr[SrcLUT]+')) / sum(Float32(CaseData/Land/IsInRunRegion)), Float32(0.0), Float32(9.0))'";
					attribute<string> EnrichmentExpr: Expr = "'MakeDefined(NeighbourData/'+Name +' / MeanEnrichData/'+Name+', Float32(0))'";
				}
			}
		}
		
		container arrangePopulationParams: IsTemplate = "True"
		{
			parameter<uint32> ZoneNum;

			container ParameterSet;
			
			unit<uint16> ZoneUnit: 		expr = "subset(ParameterSet/ZoneId = ZoneNum[uint16])";
			
			container ZoneValues: expr = "for_each_nedv(FactorReferences/FactorName, 'mean(ParameterSet/'+ FactorReferences/FactorName + '[ZoneUnit/Nr_OrgEntity])', void, float32)"
			{parameter<float32> Constant: expr = "(mean(ParameterSet/Constant[ZoneUnit/Nr_OrgEntity]))";}
			
			unit<uint32> FactorValues: expr = "FactorReferences"
			{
				attribute<float32> 	Value: 		expr = "= 'union_data(.,'+ AsItemlist(!IsNull(FactorName) ? 'ZoneValues/'+ FactorName : 'float32(0)') + ')'";
				attribute<string> 	DataRef:	expr = "!IsNull(FactorRef) ? MetaData/FactorId/VariableRef[FactorRef] : ''";
			}
			
			parameter<string> EvalSuitExpr: expr = "'float32('+ string(ZoneValues/Constant) +') + Add('+AsItemList(!IsNull(FactorValues/FactorRef) ? 'float32('+string(FactorValues/Value)+') * float32('+FactorValues/DataRef+')': '')+')'";
		}
		container arrangeLinearParams: IsTemplate = "True"
		{
			parameter<uint32> ZoneNum;
			container FactorListRef;
			container ParameterSet;
			
			unit<uint16> ZoneUnit: 		expr = "subset(ParameterSet/ZoneId = ZoneNum[uint16])";
			
			container ZoneValues: expr = "for_each_nedv(FactorReferences/FactorName, 'mean(ParameterSet/'+ FactorReferences/FactorName + '[ZoneUnit/Nr_OrgEntity])', void, float32)"
			{
				parameter<float32> Constant: 	expr = "(mean(ParameterSet/Constant[ZoneUnit/Nr_OrgEntity]))";
			}
			
			unit<uint32> FactorValues: expr = "FactorReferences"
			{
				attribute<float32> 	Value: 		expr = "= 'union_data(.,'+ AsItemlist(!IsNull(FactorName) ? 'ZoneValues/'+ FactorName : 'float32(0)') + ')'";
				attribute<string> 	DataRef:	expr = "!IsNull(FactorRef) ? FactorListRef/VariableRef[FactorRef] : ''";
			}
			//parameter<string> SimpleExpr: 	expr = "'float32(exp(float32('+ string(ZoneValues/Constant) +') + Add('+AsItemList(!IsNull(FactorValues/FactorRef) ? 'float32('+string(FactorValues/Value)+') * float32('+FactorValues/DataRef+')': '')+')))'";
			//parameter<string> proto_EvalExpr: 	expr = "'float32(exp(float32('+ string(ZoneValues/Constant) +') + Add('+AsItemList(!IsNull(FactorValues/FactorRef) ? 'float32('+string(FactorValues/Value / (float32(1) - ZoneValues/Rho))+') * float32('+FactorValues/DataRef+')': '')+')))'";
			parameter<string> EvalExpr: expr = "'float32('+ string(ZoneValues/Constant) +') + Add('+AsItemList(!IsNull(FactorValues/FactorRef) ? 'float32('+string(FactorValues/Value)+') * float32('+FactorValues/DataRef+')': '')+')'";
		}
		container arrangeSARParams: IsTemplate = "True"
		{
			parameter<uint32> ZoneNum;
			container FactorListRef;
			container ParameterSet;
			
			unit<uint16> ZoneUnit: 		expr = "subset(ParameterSet/ZoneId = ZoneNum[uint16])";
			
			container ZoneValues: expr = "for_each_nedv(FactorReferences/FactorName, 'mean(ParameterSet/'+ FactorReferences/FactorName + '[ZoneUnit/Nr_OrgEntity])', void, float32)"
			{
				parameter<float32> Constant: 	expr = "(mean(ParameterSet/Constant[ZoneUnit/Nr_OrgEntity]))";
				parameter<float32> Rho: 		expr = "(mean(ParameterSet/Rho[ZoneUnit/Nr_OrgEntity]))";
			}
			
			unit<uint32> FactorValues: expr = "FactorReferences"
			{
				attribute<float32> 	Value: 		expr = "= 'union_data(.,'+ AsItemlist(!IsNull(FactorName) ? 'ZoneValues/'+ FactorName : 'float32(0)') + ')'";
				attribute<string> 	DataRef:	expr = "!IsNull(FactorRef) ? FactorListRef/VariableRef[FactorRef] : ''";
			}
			//parameter<string> SimpleExpr: 	expr = "'float32(exp(float32('+ string(ZoneValues/Constant) +') + Add('+AsItemList(!IsNull(FactorValues/FactorRef) ? 'float32('+string(FactorValues/Value)+') * float32('+FactorValues/DataRef+')': '')+')))'";
			parameter<string> proto_EvalExpr: 	expr = "'float32(exp(float32('+ string(ZoneValues/Constant) +') + Add('+AsItemList(!IsNull(FactorValues/FactorRef) ? 'float32('+string(FactorValues/Value / (float32(1) - ZoneValues/Rho))+') * float32('+FactorValues/DataRef+')': '')+')))'";
			parameter<string> EvalExpr:			expr = "'MakeDefined(float32(1) + (((' + proto_EvalExpr + ' - float32(1)) / float32(10)) * Parameters/PeriodSet/result/PeriodLength[PeriodId]) ,float32(1))'";
		}
		container getPopParameters: IsTemplate = "True", Using = "PopSets/PopulationParameters/popcali;"
		{
			parameter<uint32> ZoneNum;
			
			unit<uint16> ZoneUnit: 		expr = "subset(ParameterSet/ZoneId = ZoneNum[uint16])";
			
			unit<uint32> Proto_Factors:			expr = "subset(popcali/factors/SuitWeight)"
			{	attribute<bool> SpatialComponent: expr = "popcali/factors/aSpatialComponent[Nr_OrgEntity]"; 
				attribute<string> 	Label: 		expr = "popcali/factors/FactorName[Nr_OrgEntity]"; 
				attribute<string> FactorCalc: expr = "popcali/factors/FactorCalc[Nr_OrgEntity]"; 
				attribute<bool> Patch: expr = "popcali/factors/Patch[Nr_OrgEntity]";
				attribute<float32> params: expr = "= 'union_data(., ' + AsItemList('ZoneParameterSet/'+ Label) + ')'";	
			}
			
			Container ZoneParameterSet: expr = "for_each_nedv(Proto_Factors/Label, 'first(ParameterSet/'+ Proto_Factors/Label + '[ZoneUnit/Nr_OrgEntity])', void, float32)";
			
			unit<uint32> ExoFactors:				expr = "subset(!Proto_Factors/SpatialComponent)"
			{	attribute<string> 	Label: 		expr = "Proto_Factors/Label[Nr_OrgEntity]"; attribute<string> FactorCalc: expr = "Proto_Factors/FactorCalc[Nr_OrgEntity]"; 
				attribute<float32>	Params:		expr = "Proto_Factors/params[Nr_OrgEntity]";
				 attribute<bool> Patch: expr = "Proto_Factors/Patch[Nr_OrgEntity] && params < float32(0)";}
			unit<uint32> Patch:					expr = "subset(Proto_Factors/Patch)"
			{	attribute<string> FactorCalc: expr = "Proto_Factors/FactorCalc[Nr_OrgEntity]"; attribute<float32> params: expr = "float32(-1) * Proto_Factors/params[Nr_OrgEntity]";}
			
			parameter<float32> 	SpatialParam:	expr = "Sum(Proto_Factors/params * float32(Proto_Factors/SpatialComponent))";
			parameter<string> 	EvalSuitExpr: 	expr = "#Factors > 0 ? add(AsList('(float32('+ string(ExoFactors/params) +') * ' + ExoFactors/FactorCalc + ')', ' + ')): 'const(0, domain, float32)'";
			parameter<string> 	PatchExpr:		expr = "#patch > 0 ? add(AsList('(float32('+ string(Patch/params) +') * ' + Patch/FactorCalc + ')', ' + ')): 'const(0, domain, float32)'";
			parameter<string> 	EvalSpatParam:	expr = "'float32(' + string(SpatialParam) + ')'";
			
			parameter<Year> 	   SupplyChange:			expr = "popcali/SupplyChange";
			parameter<uint32>	   SpatialComponent:		expr = "popcali/SpatialComponent";
			parameter<ModelSpecs>  ModelSpec: 				expr = "popcali/ModelType[ZoneNum[uint16]]";
		}
		container ReadAlloc1: IsTemplate = "True"
		{
			parameter<String> FileName;
			
			parameter<String> FileData: StorageName = "=FileName", StorageType = "str", KeepData = "True";
				
			container RegrData: Expr = "Alloc1Templ(FileData)";
			container Reordered: Expr = "Alloc1ReorderTempl(RegrData/Data)";
		}
		container ReadAlloc2: IsTemplate = "True"
		{
			parameter<String> FileName;
			container NeighbourhoodLink;
			
			parameter<String> FileData: StorageName = "=FileName", StorageType = "str", KeepData = "True";
				
			container RegrData: Expr = "Alloc2Templ(FileData)";
			container Reordered: Expr = "Alloc2ReorderTempl(RegrData/Data)";
		}
		
		container getAlloc1: IsTemplate = "True"
		{
			parameter<Meta/Run> inRegionId;
			
			container Reordered: Expr = "New_Alloc1ReorderTempl(ExogenousEffectsMatrix)";
		}
		
		container getAlloc2: IsTemplate = "True"
		{
			parameter<Meta/Run> inRegionId;
			container NeighbourhoodLink;
			
			container Reordered: Expr = "New_Alloc2ReorderTempl(NeighbourhoodEffectsMatrix)";
		}
		
	container AllocSet: IsTemplate = "True"
		{
			parameter<String> ParamPath;
			container Alloc1Reg; //: Expr = "Alloc1Reordered/Results";
			container Alloc2Reg; //: Expr = "Alloc2Reordered/Results";
			container TransitionCostLink;
			container NeigbourhoodLink;
			container PopSet;
			parameter<string> RunZoneName;
			
			//container DemandModelSets;
			
			// ==== End of Template parameters
			
			container ParamSet:  Expr = "ParamSets/ActiveSet";
			
			unit<UInt8> ModelType: Expr = "Classifications/LU/ModelType";
			unit<Uint32> Factors:		  	Expr = "MetaData/FactorID";

			container Rules
			{
				attribute<string> ggModelIdExpr(ModelType): Expr = "String(ID(ModelType))+'[ModelType]'";
				parameter<string> PopulationSuitability: 	Expr = "PopSet/EvalSuitExpr";
				parameter<string> pot_factors:				Expr = "'max_elem(potential(('+ PopulationSuitability +' + '+ Rules/PopulationPatch +')[domain/BasisGrid], Parameters/FuncKernels/RooksNeighbours/Matr)[domain/grid_rel], float32(0))' ";
				parameter<string> PopulationPatch:			Expr = "PopSet/PatchExpr";
				parameter<uint8>  ModelSpec:				Expr = "PopSet/ModelSpec";
				parameter<string> SpatParam:				Expr = "PopSet/EvalSpatParam";
				parameter<string> Population_Distribution := switch(
					case(Rules/ModelSpec = uint8(1), ' ('+ Rules/SpatParam + ' * PrevState/PotQi) + '+ Rules/PopulationSuitability), 
					case(Rules/ModelSpec = uint8(2), '(('+ Rules/SpatParam + ' * PrevState/PotQi) + '+ Rules/PopulationSuitability +') - (' + Rules/SpatParam + ' * '+ pot_factors +')'), 
					'factors_Pi');
				parameter<Year>	  SupplyChange:				Expr = "PopSet/SupplyChange";
												
				unit<UInt32> CurrFactorWeights: Expr = "Alloc1Reg/FactorWeights";
				attribute<string> SuitTermExpr (CurrFactorWeights):
					Expr = "'Rules/CurrFactorWeights/Weight['+String(ID(CurrFactorWeights))+'] * convert('+ CurrFactorWeights/VariableRef +', float32)'";
				attribute<string> SuitTermsExpr (ModelType):
					Expr = 
						"'add(const('+MakeDefined(String(Alloc1Reg/ConstWeight), ' -9999.1')+', domain, Float32)'"
						"+asList(', '+SuitTermExpr, '', CurrFactorWeights/LandUseType)+')'";
								
				attribute<string> SuitabilityExpExpr   (ModelType): Expr = "'exp(min_elem(MakeDefined(SuitabilityData/'+ModelType/Name+', Float32(-1000000)), float32(60)))'";
				attribute<string> SuitabilityLogitExpr 		(ModelType): Expr = "SuitabilityExpExpr+'/(Float32(1)+'+SuitabilityExpExpr+')'";
				attribute<string> SuitabilityRescaleExpr	(ModelType) :=
					'MakeDefined(protoSuitabilityLogit/'+ ModelType/Name + ' / nth_element(protoSuitabilityLogit/'+ ModelType/Name +', domain/p99_value), float32(0))';

				parameter<string> SuitabilitySumExpExpr: Expr = "'add('+AsItemList(SuitabilityExpExpr)+')'";
				attribute<string> SuitabilityMnlExpr   (ModelType): Expr = "SuitabilityExpExpr+' / TotalExpSuitability'";
				
				attribute<string> LocSpecExprPrefix(ModelType):		 		
		 			Expr = 
		 				"((ParamSet/LocationSpecificPreferenceAddition <> Float32(0.0))"
		 					"? ' * CaseData/LocSpec/'+ModelType/Name+'* ParamSet/LocationSpecificPreferenceAddition['+ggModelIdExpr+']'"
		 					": '')";
				
//				attribute<string> LocSpecsModifierExpr (ModelType): expr = "CombinedSuitExpr + ' * ' + LocSpecExprPrefix";
				
				attribute<string> CombinedSuitExpr(ModelType): expr = "'Suitability/'+ModelType/Name";

				attribute<string> TransitionCostsExpr(ModelType): Expr = "'value(Rules/TransitionCosts/pTab/'+ModelType/Name+', Float32)[PrevState/Landuse]'";

				attribute<string> GrossRevenuesExpr(ModelType): Expr = "'value(Rules/GrossRevenues/pTab/'+ModelType/Name+', Float32)[PrevState/Landuse]'";  	
											
				attribute<string> TransitionCostExpression(ModelType): Expr = "'SuitabilityModifiers/'+ ModelType/Name +' * (' + GrossRevenuesExpr + ') - (' + TransitionCostsExpr + ')'";
				
				attribute<string> LogitRegrResutsProbExprBase(ModelType) := AsItemList(
					'float32(PrevState/Landuse == '+string(MetaData/RegressionResults/LogitTransitions/from_rel)+'[Classifications/LU/ModelType]) '
					'* CaseData/JrcFactorData/RegressionResults/Logit/'+MetaData/RegressionResults/LogitTransitions/name+'[domain/grid_rel]'
				, 	MetaData/RegressionResults/LogitTransitions/to_rel
				);
				attribute<string> LogitRegrResutsProbExpr(ModelType) := LogitRegrResutsProbExprBase == '' ? 'const(0f, domain)' : 'add('+LogitRegrResutsProbExprBase+')';
				
				attribute<string> RfRegrResutsProbExprBase(ModelType) := AsItemList(
					'float32(PrevState/Landuse == '+string(MetaData/RegressionResults/RfTransitions/from_rel)+'[Classifications/LU/ModelType]) '
					'* CaseData/JrcFactorData/RegressionResults/RF/'+MetaData/RegressionResults/RfTransitions/name+'[domain/grid_rel]'
				, 	MetaData/RegressionResults/RfTransitions/to_rel
				);
				attribute<string> RfRegrResutsProbExpr(ModelType) := RfRegrResutsProbExprBase == '' ? 'const(0f, domain)' : 'add('+RfRegrResutsProbExprBase+')';
				
				attribute<string> TotalSuitabilityExpr(ModelType) := RfRegrResutsProbExpr + ' * 0.5f + ' + LogitRegrResutsProbExpr + ' * 0.5f + ' + CombinedSuitExpr + LocSpecExprPrefix + '- (' + TransitionCostsExpr + ')';
				
				unit<UInt32> Factor2Weights:    Expr = "Alloc2Reg/FactorWeights";
				unit<UInt32> UniqueFactor2Func: Expr = "Alloc2Reg/UniqueFactorFuncs";
				attribute<string> DynamicNeigbourPotentialExpr0(ModelType): //new for restoring original neighbourhood values (excluding enrichment)
					Expr = 
						"asItemList('Value('+String(Factor2Weights/Weight)+', EUR_M2)"
						"*PotentialData/'+UniqueFactor2Func/Name[Factor2Weights/UFF_rel], Factor2Weights/LandUseType)";
		
				attribute<bool>   HasDynamicNeighbourInfluence(ModelType): Expr = "pcount(Factor2Weights/LandUseType)>0";
				attribute<string> DynamicNeighbourPotentialExpr (ModelType): Expr =  "HasDynamicNeighbourInfluence ? 'add('+DynamicNeigbourPotentialExpr0  +')' : 'const(0,domain,EUR_M2)'"; // was DynamicNeigbourExpr1
				//attribute<string> DynamicNeighbourEnrichmentExpr(ModelType): Expr =  "HasDynamicNeighbourInfluence ? 'add('+DynamicNeigbourEnrichmentExpr0 +')' : 'const(0,domain,EUR_M2)'";
						
				attribute<string> DynamicNeighbourExpExpr   (ModelType): Expr = "'exp(min_elem(value('+String(Alloc2Reg/ConstWeight)+', EUR_M2)'+(HasDynamicNeighbourInfluence ? '+DynamicNeighbourData/'+ModelType/Name : '')+', float32(80)))'";
				//attribute<string> DynamicNeighbourLogitExpr0(ModelType): Expr = "DynamicNeighbourExpExpr+'/(Float32(1)+'+DynamicNeighbourExpExpr+')'";
				//attribute<string> DynamicNeighbourLogitExpr (ModelType): Expr = "HasDynamicNeighbourInfluence ? DynamicNeighbourLogitExpr0 : 'const('+DynamicNeighbourLogitExpr0+',domain)'";
				
				parameter<string> DynamicNeighbourSumExpExpr  : Expr = "'add('+AsItemList(DynamicNeighbourExpExpr)+')'";
				attribute<string> DynamicNeighbourMnlExpr  (ModelType): Expr = "DynamicNeighbourExpExpr+' / TotalExpNeighbour'";
				
				Container TransitionCosts: expr = "TransitionCostLink";
				//Container GrossRevenues: expr = "GrossRevenuesLink";
				Container Neighbourhood: expr = "NeigbourhoodLink";
				
				unit<uint32> ModelMatr := Classifications/Lu/ModelMatr;
			}
		}
		container EU_Wide_TableChopper: IsTemplate = "True"
		{
			parameter<string> name;
			unit<uint32> Zones;
			
			parameter<String> File: StorageName = "= '%ProjDir%/Demand/'+ name +'.csv'", StorageType = "str"; 
			parameter<String> HeaderLine: Expr = "ReadLines(File, void, 0)";
			 parameter<Bool>   HeaderOK:   expr = "regex_match(HeaderLine, '[^,]++(,[^,]++)*+')";
			unit<uint32>  PopField: Expr = "range(uint32, 0, strcount(HeaderLine, ','))", IntegrityCheck = "HeaderOK"
			{
				attribute<String> 	Name: 					Expr = "ReadArray(HeaderLine, PopField, string, strpos(HeaderLine, ',')+1)";
				attribute<bool>		IsYear: 				Expr = "uppercase(substr(Name,0,1)) = 'Y'";
				attribute<UInt16> 	Year: 					Expr = "uppercase(substr(Name,0,1)) = 'Y' ? UInt16(substr(Name, strlen(Name)-4, 4)) : Uint16(0 / 0)";
				attribute<PeriodSet/result> ModelYearRel: 	Expr = "rlookup(float32(Year), PeriodSet/result/ProjectedYear)";
			}
			unit<UInt32> BodyDomain := Range(UInt32, 0, strcount(File, '\n')-1)
			{
				attribute<string> Line: Expr = "ReadLines(File, BodyDomain, HeaderLine/ReadPos)";
				attribute<Bool> LinesAreNuts2CodeAndIntegers(BodyDomain): expr = "regex_match(Line, '[A-Z][A-Z]([A-Z]|[0-9])?+([A-Z]|[0-9])?+(,([0-9]++))*+')";
				
				attribute<String> ZoneId: Expr = "ReadElems(Line, string, const(0, BodyDomain))";//, IntegrityCheck = "LinesAreNuts2CodeAndIntegers";
				attribute<Zones> ZoneRel := rlookup(ZoneId,Zones/ZoneId);
				container Data := for_each_nedv(PopField/Name
						,'ReadElems(Line,float32,'+MakeDefined(PopField/Name[sub_or_null(ID(PopField), 1)]+'/ReadPos','ZoneId/ReadPos')+')'
						, BodyDomain,float32
					);
			}
			container InColumns: expr = "for_each_nedv(PopField/Name, 'sum(BodyDomain/Data/'+ PopField/Name +', BodyDomain/ZoneRel)', Zones, float32)";
			
			unit<uint32> Years: expr = "subset(PopField/IsYear)" 
			{
				attribute<string> Name: expr = "PopField/Name[Nr_OrgEntity]"; 
				attribute<YearRange> ForYear: expr = "float32(PopField/Year[Nr_OrgEntity])[YearRange]";
				attribute<PeriodSet/result> ModelYearRel: expr = "PopField/ModelYearRel[Nr_OrgEntity]"; 
				attribute<string> ref: expr = "const('Zones',.,string)";
			}
			
			unit<uint32> Data: expr = "= 'union_unit('+ AsItemList(Years/ref)  +')'"
			{
				attribute<float32> 		Pop: 		expr = "= 'union_data(.,'+ AsItemList('InColumns/'+ Years/Name) +')'";
				attribute<YearRange> 	ForYear:	expr = "= 'union_data(.,'+ AsItemList('const(float32('+string(Years/ForYear)+'),Zones,YearRange)') +')'";
				attribute<Zones>		ZoneRel:	expr = "= 'union_data(.,'+ AsItemList('id('+ Years/Ref + ')') +')'";
				attribute<YearRange> 	Year:		expr = "PeriodSet/result/ProjectedYear[rlookup(float32(ForYear), PeriodSet/result/ProjectedYear)]";
			}
			
			unit<uint32> Domain: expr = "Data" {attribute<string> Label: expr = "Zones/Label[ZoneRel]";}
			
		}
		
		template ClaimTableTemplateTableChopper
		{
			// begin case parameter
			unit<Uint32>      RegionDomain;
			parameter<string> RegionDomainName;
			parameter<string> ScenarioName;
			parameter<string> RegionName;
			// end case parameter

			parameter<String> FileName   := '%projdir%/demand/' + ScenarioName + '/' + replace_value(RegionDomainName, 'Capri', 'Capri23') + '/' + RegionName + '.csv';
			parameter<String> FieldSeparator := strcount(FileData, ',') > strcount(FileData, ';') ? ',' : ';';
		
			parameter<String> FileData
			:	StorageType = "str"
			,	StorageName = "=FileName";
			parameter<String> HeaderLine: expr = "readLines(FileData, void, 0)";
// 			parameter<Bool>   HeaderOK:   expr = 
// 				"regex_match("
// 					" HeaderLine"
// 					",'\"[^\"]*+\"(,\"[^\"]*+\")*+'"
// 				")";

			unit<UInt32> Field: expr = "Range(UInt32, 0, strcount(HeaderLine, FieldSeparator)+1)"
			{
				attribute<String> Name: Expr = 
				"ReadArray(HeaderLine, Field, String, 0)";
			}
			unit<uint32> Domain: expr = "Range(UInt32, 0, strcount(FileData, '\n')-1)"
			{
//				attribute<.> id: expr = "id(.)";
				attribute<String> Label := Data/RegionUp, DialogType = "LabelText";
			}
			
			attribute<String> BodyLines(Domain) := readLines(FileData, Domain, HeaderLine/ReadPos);
// 			,	IntegrityCheck = "HeaderOK";
// 			attribute<Bool> LinesAreSignedIntegerStringOrEmpy (Domain): expr = 
// 				"regex_match("
// 					" BodyLines"
// 					",'(-?+[0-9]++|\"[^\"]*+\")?+(;(-?+[0-9]++|\"[^\"]*+\")?+)*+'"
// 				")";
			
			container Data := for_each_nedv(Field/Name
					, 'ReadElems(BodyLines, string, '+MakeDefined(Field/Name[sub_or_null(ID(Field), 1)]+'/ReadPos', 'const(0,Domain)')+')'
					, Domain, string
				)
			{
				attribute<String> RegionUp_Raw (Domain):= = RegionDomainName == 'Capri' ? 'UpperCase(luisa_nuts2)' : 'UpperCase(Region)';
				attribute<String> RegionUp     (Domain):= replace_value(RegionUp_Raw, 'BELUX', 'BL');
				attribute<UInt32> ZeroClaim    (Domain):= const(0,Domain);
				attribute<UInt32> HighClaim    (Domain):= const(2000000000,Domain);
				
				// extra code for integrity check on Region Codes:
				// they should all be known as codes in the corresponding Domain (which refers to a specific column in CAPRI_NUTS2_correspondences.xls)
				// except for a limitative list of explicitly defined exceptions (now this list only contains 1 entry).
				// one region_exception is necessary as the demand files contain also aggregated demands per country
				// The region exception checks on the pattern: rc00 (rc = a known region code prefix)
				
				attribute<RegionDomain> region_nr  (Domain) := rlookup(RegionUp, RegionDomain/ZoneId);
				attribute<bool> region_prefixKnown (Domain) := IsDefined(rlookup(substr(RegionUp, 0, 2),substr(RegionDomain/ZoneId, 0, 2))) || RegionUp == 'BL';
				attribute<bool> region_exception1  (Domain) := (strlen(RegionUp_Raw) == 4) && region_prefixKnown && (substr(RegionUp_Raw, 2, 2) == '00') || substr(RegionUp_Raw, 0, 2) == 'UK';
				attribute<bool> region_allowed     (Domain) := isDefined(region_nr) || (region_exception1) || RegionUp == 'BL' || RegionUp == 'PT20' || RegionUp == 'PT30';
				
				attribute<Domain> rel_curr_years	(PeriodSet/result) := rlookup(PeriodSet/result/ProjectedYear, value(year, float32));
				attribute<bool> check_rel			(PeriodSet/result) := IsDefined(rel_curr_years);
				
			}
		}
		
		template DemandSet
		{
			parameter<String> DemandDirname;
			
			container ParamSet:  Expr = "ParamSets/ActiveSet";
			
			container Global: expr = "../Global";
			
			unit<uint8> ModelType: expr = "Classifications/LU/ModelType";
			
			
			unit<UInt8> DC: Expr = "MetaData/DemandCharacteristics";
			attribute<String> RegionRefs		(DC): Expr = "DC/OrgRegion";
			
			unit<uint8> RunRegionDemands: expr = "subset(!DC/EU)" {attribute<string> Regions:	expr = "RegionRefs[Nr_OrgEntity]";}
			
			attribute<String> DestRegionRefs	(DC): Expr = "DC/ModelRegion";
			
			unit<UInt8> UniqueRegionRefs: Expr = "unique(RegionRefs)";
			unit<UInt8> UniqueDestRegionRefs: Expr = "unique(DestRegionRefs)";
			unit<UInt8> RunRegion_Specific_RegionRefs: expr = "unique(RunRegionDemands/Regions)";
			unit<UInt8>	UnionedRegionRefs := union_unit_uint8(UniqueRegionRefs, UniqueDestRegionRefs) 
			{
				attribute<string> Values := union_data(., UniqueRegionRefs/Values, UniqueDestRegionRefs/Values);
			}
			
			unit<uint8> AllRegionRefs := unique(UnionedRegionRefs/Values);
			
			container ClaimTablesOrg: FreeData = "False", StoreData = "True", Using = "Parameters/DemandSets/Global", Expr = 
				"for_each_ne("
					" RunRegion_Specific_RegionRefs/Values"
					",'ClaimTableTemplateTableChopper("
						" Geography/Regions/'+RunRegion_Specific_RegionRefs/Values +'
						, '+ quote(RunRegion_Specific_RegionRefs/Values) + '
						, ParamSet/ParamName
						, DemandDirName"
					")'"
				")";
								
			parameter<Bool> ClaimTablesOK: Expr = "='and('+asItemList('all(ClaimTablesOrg/'+RunRegion_Specific_RegionRefs/Values+'/Data/region_allowed), all(ClaimTablesOrg/'+RunRegion_Specific_RegionRefs/Values+'/Data/check_rel)')+')'";
						
					
			// ============ claims; overrule Capri/data: ArableMin and ArableMax
			container ClaimTables := ClaimTablesOrg, IntegrityCheck = "ClaimTablesOK"
			{
				container Capri := ClaimTablesOrg/Capri {
					unit<uint32> Domain := ClaimTablesOrg/Capri/Domain;
					
					parameter<float32> Arable_Width_factor := float32(replace_value(Expand(., '%env:ARABLE_WIDTH%'), 'env:ARABLE_WIDTH', '0.20'));
					parameter<float32> Arable_Inc_factor   := float32(replace_value(Expand(., '%env:ARABLE_INC%'  ), 'env:ARABLE_INC'  , '0.00'));
					
					container data := ClaimTablesOrg/Capri/data {
						attribute<float32> ArableMin_org(Domain) := float32(ClaimTablesOrg/Capri/data/Arable);
						attribute<float32> ArableMax_org(Domain) := float32(ClaimTablesOrg/Capri/data/Arable);
						attribute<float32> ArableMid_org(Domain) := 0.5f * (ArableMin_org+ArableMax_org);
						attribute<float32> ArableMid    (Domain) := ArableMid_org * (1f+iif(Uint32(Data/year) < 2019, 0f, Arable_Inc_factor));
						
						attribute<float32> ArableMin    (Domain) := ArableMid * (1f - Arable_Width_factor);
						attribute<float32> ArableMax    (Domain) := ArableMid * (1f + Arable_Width_factor);
						attribute<float32> NewEnergyMin (Domain) := const(0f, Domain);
						attribute<float32> NewEnergyMax (Domain) := const(0f, Domain);
						attribute<float32> PasturesMin  (Domain) := float32(ClaimTablesOrg/Capri/data/Pastures);
						attribute<float32> PasturesMax  (Domain) := float32(ClaimTablesOrg/Capri/data/Pastures);
						attribute<float32> PermCropsMin (Domain) := float32(ClaimTablesOrg/Capri/data/PermanentCrops);
						attribute<float32> PermCropsMax (Domain) := float32(ClaimTablesOrg/Capri/data/PermanentCrops);
					}
				}
			}
		}
		container Run : IsTemplate = "True"
		{
			parameter<String> Name;
			container AllocSet;
			container DemandSet;
			parameter<String> SuitabilityTraits;
			// ==== End of Template parameters
			
			parameter<String> DemandDirName: Expr = "DemandSet/DemandDirName";
			
			container ParamSet:  Expr = "AllocSet/ParamSet";
			
			unit<UInt8> ModelType: Expr = "AllocSet/ModelType";
			unit<UInt32> Factors := AllocSet/Factors;
			//container Neighbourhood: Expr = "Rules/Neighbourhood"; // not necessary 17 jun 2013 because neighmatrices are now country-specific CJC
			
			unit<UInt16> Periods:   Expr = "PeriodSet/result";
// 			unit<UInt16> Decennium: Expr = "PeriodSet/Decennium";
// 			unit<UInt16> Lustrum:   Expr = "PeriodSet/Lustrum";

			parameter<String> OutputDir := ParamSets/ActiveSet/OutputFolderName + '/' + replace(Name, '/', '_');
		}
	}
	container ParamSets 
	{
		container StatusQuo {
			parameter<String> ParamName := 'StatusQuo';  	// @USERINPUT
			
			parameter<String> ParamPath:   Expr = "'%projdir%/ParamSets/'+ ParamName";
			parameter<String> LocSpecPath: Expr = "'%LuisettaDataDir%/LocSpec/' + ParamName";
			unit<UInt8>       ModelType: Expr = "Classifications/LU/ModelType";
//			parameter<String> OrgLandUseExpr: Expr= "'CorineGrid/Jrc9Data'";
			
			// @USERINPUT, just use 0 or 1 (or anything in between if you really need to)
			// LocationSpecificPreferenceAddition is used in TotalSuitability/X as factor for CaseData/LocSpec/XXX, thus
			//
			// TotalSuitability := exp(SuitabilityData/XXX)/its sum * CaseData/LocSpec/XXX * LocationSpecificPreferenceAddition
			//
			// which, for small variations, is comparable to  
			//
			// log(TotalSuitability) := SuitabilityData/XXX - log(its sum of exponents) + log(CaseData/LocSpec/XXX) + log(LocationSpecificPreferenceAddition)
			attribute<Float32> LocationSpecificPreferenceAddition(ModelType): 
			
			[
				0, 1,     // urb, ind
				1, 1, 1,  // arabl, permacrops, pastures
				1, 1,     // forestmat, transwoodland
				0, 0, 0, 0, 0,     // Abandoned Arable, PC, Pasture, Urban, Industry 
				1, 1, 1	  //NewEnergyCrops, SHVA, ForestsYoung
			];
			parameter<String> LocSpecContainerName: Expr = "'ReferenceLocSpecs'";
			
//			parameter<String> AllowedFile:StorageName = "=ParamPath+'/allow.txt'",    StorageType = "str", KeepData = "True";
			parameter<String> TransitionCostsFile:  StorageName = "=ParamPath+'/TransitionCosts.txt'", StorageType = "str", KeepData = "True";
//			parameter<String> GrossRevenuesFile:  StorageName = "=ParamPath+'/GrossRevenues.txt'", StorageType = "str", KeepData = "True";			
			parameter<String> NeighbFile: expr = "= quote(ParamPath+'/neighmat.txt')"; //, StorageType = "str", KeepData = "True";
			container TransitionCosts:   Expr = "Templ/TransitionCostsTempl(TransitionCostsFile)";
//			container GrossRevenues:   Expr = "Templ/GrossRevenuesTempl(GrossRevenuesFile)";			
			container Neighbourhood: Expr = "Templ/NeighbTempl(NeighbFile)";
			
			parameter<bool>	PopulationSpillovers: expr = "False";
		}
		container ActiveSet := StatusQuo   // @USERINPUT, use these lines to switch between StatusQuo and Integration
		{
			parameter<String> FolderName := replace_value(Expand(., '%env:DIR_OUTPUT%'), 'env:DIR_OUTPUT', 'GUI');
			parameter<string> OutputFolderName := '%projdir%/results/Extensification/' + replace(FolderName, '/', '_');
		}
		//container ActiveSet: Expr = "NoCAP";   // @USERINPUT, use these lines to switch between StatusQuo and Integration
//		container ActiveSet: Expr = "Integration"; // @USERINPUT, use these lines to switch between StatusQuo and Integration
	}
	
	// ==== Copied from EuClueScanner100m.dms
	container Meta
	{
		unit<UInt16> Run: Expr = "Geography/Regions/Runs"
		{
			attribute<String> Region100Name:    	Expr = "RegionDomainSetName+'/'+Name";
			attribute<String> PopParamsRegionName: 	Expr = "Name";			
			attribute<String> Code:					Expr = "ICC";
		}
		
		//container Alloc1Set: 			Expr = "Templ/UniqueAllocSet('Alloc/', 'alloc1.reg')";	
		//container Alloc2Set: 			Expr = "Templ/UniqueAllocSet('Alloc/', 'alloc2.reg')";
		container TransitionCostSet:	Expr = "Templ/UniqueAllocSet('TransitionCosts/', '_TransitionCosts.txt')";
		container GrossRevenuesSet:	Expr = "Templ/UniqueAllocSet('GrossRevenues/', '_GrossRevenues.txt')";		
		container NeighbourhoodSet:		Expr = "Templ/UniqueAllocSet('Neighmats/', '_neighmat.txt')";
		
		unit<UInt16> DemandSet: Expr = "Unique(Run/DemandDirName)"
		{
			attribute<String> Name:          Expr = "Values";
			attribute<String> DemandDirName: Expr = "Values";
		}
	}
	
	container ExogenousParams: 		expr = "for_each_ne(Classifications/LU/ModelType/Name, 'Templ/getExogenousParams(Geography/Regions/Nuts0_LUISA,'+ string(id(Classifications/LU/ModelType)) + '[Classifications/LU/ModelType])')"
	{
		unit<uint32> ExogenousEffectsMatrix: expr = "= 'union_unit('+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/UnitsFactors') +')'"
		{ 
			attribute<Meta/Run>						Regionid:	expr = "= 'union_data(., '		+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/UnitsFactors/UnitId') +')'";
			attribute<Classifications/LU/ModelType> LandUseType:expr = "= 'union_data(., '		+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/UnitsFactors/LandUseType') +')'";
			attribute<MetaData/FactorID>			FactorId:	expr = "= 'union_data(., '		+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/UnitsFactors/FactorRef') +')'";
			attribute<float32>						Weight:		expr = "= 'value(union_data(., '+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/UnitsFactors/Weight') +'), float32)'";
			
			unit<uint32> Constants: expr = "= 'union_unit('+ AsItemList(Classifications/LU/ModelType/Name + '/RunsRef') +')'"
			{
				attribute<float32> 						Weight: 	expr = "= 'union_data(.,'+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/Constant') +')'";
				attribute<Meta/Run>						RegionId: 	expr = "= 'union_data(.,'+ AsItemList('id(' + Classifications/LU/ModelType/Name + '/RunsRef)') +')'";
				attribute<Classifications/LU/ModelType>	LandUseType:expr = "= 'union_data(.,'+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/LandUseType') +')'";
			}
		}
		container ExogenousEffectsSets: Expr = "for_each_ne(Meta/Run/Name, 'Templ/getAlloc1(uint16('+string(id(Meta/Run))+'))')";
	}
	container NeighbourhoodParams: 	expr = "for_each_ne(Classifications/LU/ModelType/Name, 'Templ/getNeighbourhoodParams(Meta/Run,'+ string(id(Classifications/LU/ModelType)) + '[Classifications/LU/ModelType])')"
	{
		unit<uint32> NeighbourhoodEffectsMatrix: expr = "= 'union_unit('+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/UnitsFactors') +')'"
		{
			attribute<Meta/Run>						Regionid:	 expr = "= 'union_data(., '+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/UnitsFactors/UnitId') +')'";
			attribute<Classifications/LU/ModelType> LandUseType: expr = "= 'union_data(., '+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/UnitsFactors/LandUseType') +')'";
			attribute<Classifications/LU/ModelType> SrcLUT:		 expr = "= 'union_data(., '+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/UnitsFactors/SrcLUT') +')'";
			attribute<float32>						Weight:		 expr = "= 'value(union_data(., '+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/UnitsFactors/Weight') +'), float32)'";
			attribute<uint8>						Func:		 expr = "= 'union_data(., '+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/UnitsFactors/Func') +')'";
			
			unit<uint32> Constants: expr = "= 'union_unit('+ AsItemList(Classifications/LU/ModelType/Name + '/UnitRef') +')'"
			{ 
				attribute<float32> 						Weight: 	expr = "= 'union_data(.,'+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/Constant') +')'";
				attribute<Meta/Run>						RegionId: 	expr = "= 'union_data(.,'+ AsItemList('id(' + Classifications/LU/ModelType/Name + '/UnitRef)') +')'";
				attribute<Classifications/LU/ModelType>	LandUseType:expr = "= 'union_data(.,'+ AsItemList(Classifications/LU/ModelType/Name + '/TableChopper/Data/LandUseType') +')'";
			}
			
		}
		container NeighbourhoodEffectsSets: Expr = "for_each_ne(Meta/Run/Name, 'Templ/getAlloc2(uint16('+string(id(Meta/Run))+'), NeighbourhoodSets/' + Meta/Run/ICC + ' )')";
	}
	
	
	
	/*Code below used to derive table-structured calibration files from original calibration result files
	// Written by Chris Jacobs-Crisioni March 2014
	Container Alloc1Aggr: expr = "for_each_ne(Classifications/LU/ModelType/Name, 'Templ/Alloc1_Weight_Aggregation_Templ(Meta/Run,'+ quote(Classifications/LU/ModelType/Name) + ')')"
	{attribute<string> alloc1_writecheck (Classifications/LU/ModelType): expr = "= 'union_data(Classifications/LU/ModelType, '+ AsItemList(Classifications/LU/ModelType/Name + '/Weights/TableComposer/result') +')'";}
	
	Container Alloc2Aggr: expr = "for_each_ne(Classifications/LU/ModelType/Name, 'Templ/Alloc2_Weight_Aggregation_Templ(Meta/Run,'+ quote(Classifications/LU/ModelType/Name) + ')')"
	{attribute<string> alloc2_writecheck (Classifications/LU/ModelType): expr = "= 'union_data(Classifications/LU/ModelType, '+ AsItemList(Classifications/LU/ModelType/Name + '/Weights/TableComposer/result') +')'";}	
	*/
	
	
	
	
	
	container PopSets: expr = "for_each_ne(Meta/Run/Name, 'Templ/getPopParameters(' + string(id(Meta/Run)) + ')' )"
	{
		#include<RegionalPopulation.dms>
		#include<PopulationParameters.dms>
	}			
	container TransitionCostSets:
		Expr = "for_each_ne("
				"Meta/TransitionCostSet/UniqueFiles/name, "
				"'Templ/TransitionCostsTempl2('+Quote(Meta/TransitionCostSet/UniqueFiles/Values)+')'"
			")";
	container NeighbourhoodSets:
		Expr = "for_each_ne("
				"Meta/NeighbourhoodSet/UniqueFiles/name, "
				"'Templ/NeighbTempl('+Quote(Meta/NeighbourhoodSet/UniqueFiles/Values)+')'"
			")";
	container GHG_Factors: Descr = "http://www.mantis.objectvision.nl/view.php?id=1189" 
	{
		unit<uint32> LUC: nrofrows = 4 {
			attribute<string> name: ['Forest', 'Cropland', 'Grassland', 'Settlement'];
			attribute<string> Label := name, DialogType = "LabelText";
			attribute<uint32> ColorBase: 
			[
				rgb(0, 1, 0), rgb(1, 1, 0), rgb(0, 1, 1), rgb(1, 0, 0)
			];
			attribute<uint32> BrushColor := ColorBase * 128 + (255-128)*rgb(1,1,1), DialogType = "BrushColor";
			
			attribute<.> per_ModelType(Classifications/LU/ModelType): [
				3, 3,  // Urban, Industrial
				2, 2,  // Arable, PermanentCrops
				1,     // Pastures
				0, 0,  // ForestsMature, TransWoodlandShrub
				2, 2, 1, 3, 3, // Abandoned xxx
				2,     // NewEnergyCrops
				null,  // SHVA
				0      // ForestsYoung
			];
		}
		unit<uint8> transition : nrofrows = 13 {
			attribute<string> Name : [ 
				'A1',  'A21', 'A22',
				'B21', 'B1',  'B22',
				'C21', 'C22', 'C1',
				'E21', 'E22', 'E23', 'E1'
			];
			attribute<string> Label := name + ': '+LUC/name[from]+'-> '+LUC/name[to], DialogType = "LabelText";
			attribute<uint32> BrushColor := 
				(from == to)
					? LUC/ColorBase[to] * 64 + (255-64) * rgb(1,1,1)
					: LUC/ColorBase[to] * 128 + LUC/ColorBase[from]*96
			,	DialogType = "BrushColor";
			
			attribute<string> FileName := '4'+Name;
			attribute<LUC> from: [
				0, 1, 2,
				0, 1, 2,
				0, 1, 2,
				0, 1, 2, 3
			];
			attribute<LUC> to: [
				0, 0, 0, 
				1, 1, 1,
				2, 2, 2,
				3, 3, 3, 3
			];
		}
		unit<uint32> Parties : nrofrows = 31 {
			attribute<string> Party_code: [
				'AUT','BEL','BGR','HRV','CYP','CZE','DNM','EST','FIN','FRK','DEU','GRC','HUN','IRL','ITA','LVA','LTU','LUX','MLT','NLD','POL','PRT','ROU','SVK','SVN','ESP','SWE','GBE','EU-28','ISL','GBK'
			];
			attribute<string> ICC_code: [ 
				'AT','BL','BG','HR','CY','CZ','DK','EE','FI','FR','DE','EL','HU','IE','IT','LV','LT','BL', 'MT','NL','PL','PT','RO','SK','SI','ES','SE','UK','EU-28','IS','???'
			];
			attribute<Geography/Regions/JrcRegion> JrcRegion_rel := rlookup(ICC_code, Geography/Regions/JrcRegion/ICC);
		}
		
		container transitions := for_each_ind('nxat', transition/name, uint32, '%projdir%/ParamSets/GHG/'+transition/FileName+'.csv', 'gdal.vect');
	}
	container CapMod: Descr = "http://www.mantis.objectvision.nl/view.php?id=1189"
	{
		unit<uint8>  LUC: nrofrows = 5
		{
			attribute<string> name: [ 'arable_fert', 'grass_fert', 'necr_fert', 'perm_fert', 'livestock'];
			attribute<string> colName: [ 'fert_kg_ha', 'fert_kg_ha', 'fert_kg_ha', 'fert_kg_ha', 'numheads_1000s'];
			attribute<.> per_ModelType(Classifications/LU/ModelType): [
				null, null,  // Urban, Industrial
				0, 3,  // Arable, PermanentCrops
				1,     // Pastures
				null, null,  // ForestsMature, TransWoodlandShrub
				2,     // NewEnergyCrops
				null,  // SHVA
				null   // ForestsYoung
			];
			attribute<classifications/LU/ModelType> ModelType_rel := invert(per_ModelType);
			attribute<uint32> Color := classifications/LU/ModelType/Color[ModelType_rel], DialogType = "BrushColor";
		}
		unit<uint16> Period := PeriodSet/result;
		
		template oneYearT {
			unit<uint32> all_data;
			parameter<Period> Period_rel;
			unit<uint32> year_data := subset(Float32(all_data/year) == period/ProjectedYear[period_rel])
			,	DialogType = "Map", DialogData = "Capri_rel"
			{
				attribute<Geography/Regions/Capri> Capri_rel := all_data/Capri_rel[nr_OrgEntity];
				attribute<Float32> intensity := all_data/Intensity[nr_OrgEntity];
			}
		}
		template readT {
			parameter<string> luc_name;
			parameter<string> column_name;
			unit<uint32> all_data: StorageName = "='%SourceRootDir%/EFDM/data/capmod/'+luc_name+'.csv'", StorageType = "gdal.vect", StorageReadOnly = "True"
			,	DialogType = "Map", DialogData = "Capri_rel"
			{
				attribute<Geography/Regions/Capri> Capri_rel := rlookup(left(region,4), Geography/Regions/Capri/code);				
				attribute<Float32> Intensity := ='Float32('+column_name+')';
			}
			container Years := for_each_ne(Period/name, 'oneYearT(all_data,'+string(id(Period))+'w)');
		}
		container data := for_each_ne(LUC/name, 'readT('+Quote(LUC/name)+','+Quote(LUC/colName)+')');
		
	}

	attribute<String> AllocSetComposer(Meta/Run): Expr = 
				"'Templ/AllocSet('"
					"+Quote(ParamSets/ActiveSet/ParamPath)+','"
					"+'ExogenousParams/ExogenousEffectsSets/'+Meta/Run/name+'/Reordered/Results,'"
					"+'NeighbourhoodParams/NeighbourhoodEffectsSets/'+Meta/Run/name+'/Reordered/Results,'"
					"+'TransitionCostSets/'+Meta/TransitionCostSet/name+','"
//					"+'GrossRevenuesSets/'+Meta/GrossRevenuesSet/name+','"					
					"+'NeighbourhoodSets/'+Meta/NeighbourhoodSet/name+','"
					"+'PopSets/'+Meta/Run/PopParamsRegionName +','"
					"+quote(Meta/Run/Name)+"
					//"+'DemandSets/DemandModels/residential_density_change/genExpressions/' + Meta/Run/name+"
				"')'";
	container AllocSets: // OPTIMIZE FOR UNIQUE (Alloc1, Alloc2) pairs
		Expr = 
			"for_each_ne("
				"Meta/Run/Name, "
				"AllocSetComposer"
			")";

	container DemandSets:
		Expr = 
			"for_each_ne("
				"Meta/DemandSet/Name, "
				"'Templ/DemandSet('"
					"+Quote(Meta/DemandSet/DemandDirName)+"
				"')'"
			")", Using = "MetaData;"
	{
		parameter<Bool> AllClaimTablesOK: Expr = "='and('+asItemList('DemandSets/'+Meta/DemandSet/Name+'/ClaimTablesOK')+')'";

		
		container Global: FreeData = "False", StoreData = "True"
		{
			container Pop2012: 			expr = "Templ/EU_Wide_TableChopper('Pop2012', Geography/Regions/Nuts3_LUISA)";
			container PopProjections: 	expr = "Templ/EU_Wide_TableChopper('popproj', Geography/Regions/Nuts2_LUISA)";
			container MinUrban: 		expr = "Templ/EU_Wide_TableChopper('StatusQuo/min_urban', Geography/Regions/Nuts2_LUISA)";
			container MaxUrban: 		expr = "Templ/EU_Wide_TableChopper('StatusQuo/max_urban', Geography/Regions/Nuts2_LUISA)";
		//	container Employment: expr = "Templ/EU_Wide_TableChopper('Employment', Geography/Regions/Nuts3_LUISA)";
		//	container GDP_Per_Capita: expr = "Templ/EU_Wide_TableChopper('GDP_Per_Capita', Geography/Regions/Nuts3_LUISA)";
		}
	}
	container Runs:
		Expr = 
			"for_each_ne("
				"Meta/Run/Name, "
				"'Templ/Run('"
					"+Quote(Meta/Run/Name)+','"
					"+'AllocSets/' +Meta/Run/Name+','+" // OPTIMIZE FOR UNIQUE  (Alloc1, Alloc2) pairs
					"+'DemandSets/'+Meta/Run/DemandDirName+','+"
					"+Quote(Meta/Run/SuitabilityTraits)+"
				"')'"
			")";
}
                                 